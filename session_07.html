<!DOCTYPE html>
<html lang="en">
	<head>
		<title>C++ lab sessions</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<style type="text/css">
			body {
				padding-top: 70px;
			}
			.footer {
				border-top: 1px solid #eee;
				margin-top: 20px;
				padding-top: 20px;
				padding-bottom: 10px;
			}
			h2 {
				padding-top: 60px;
			}
		</style>
		<!-- Google prettify -->
		<link href="js/google-code-prettify/my-prettify.css" rel="stylesheet">
		<!--<link href="http://twitter.github.io/bootstrap/assets/js/google-code-prettify/prettify.css" rel="stylesheet">-->
	</head>
	<body onLoad="prettyPrint()" data-spy="scroll" data-target="#subnavigation">
		<div class="container">
			<div class="navbar navbar-default navbar-fixed-top hidden-print">
				<div class="container">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
					</div>
					<div class="navbar-collapse collapse">
						<ul class="nav navbar-nav">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									C++ lab sessions
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<li><a tabindex="-1" href="index.html">Overview</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="session_00.html">Session 0 (07/10/2021)</a></li>
<li><a tabindex="-1" href="session_01.html">Session 1 (14/10/2021)</a></li>
<li><a tabindex="-1" href="session_02.html">Session 2 (21/10/2021)</a></li>
<li><a tabindex="-1" href="session_03.html">Session 3 (28/10/2021)</a></li>
<li><a tabindex="-1" href="session_04.html">Session 4 (04/11/2021)</a></li>
<li><a tabindex="-1" href="session_05.html">Session 5 (18/11/2021)</a></li>
<li><a tabindex="-1" href="session_06.html">Session 6 (24/11/2021)</a></li>
<li class="active"><a tabindex="-1" href="session_07.html">Session 7 (02/12/2021)</a></li>

								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									Quick links
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<!-- Hard coded links to useful sites, open in new tab -->
									<li><a tabindex="-1" href="http://www.cplusplus.com/" target="_blank">cplusplus.com</a></li>
									<li><a tabindex="-1" href="http://en.cppreference.com/" target="_blank">cppreference.com</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://www.cmake.org/Wiki/CMake_FAQ" target="_blank">CMake documentation</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://git-scm.com/book" target="_blank">Git documentation</a></li>
									<li><a tabindex="-1" href="http://hgbook.red-bean.com/" target="_blank">Mercurial documentation</a></li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</div>

			<div class="container">
				<div class="row">
					<!-- Subnav bar is only visible on large devices -->
					<div id="subnavigation" class="col-lg-3 col-md-3 visible-md visible-lg hidden-print">
						<ul class="nav nav-pills nav-stacked" style="position: fixed">
							<h3>Jump to:</h3>
							<li><a tabindex="-1" href="#summary">Summary</a></li>
<li><a tabindex="-1" href="#pointerstomemberfunctions">Pointers to member functions</a></li>
<li><a tabindex="-1" href="#lambdafunctions">Lambda functions</a></li>
<li><a tabindex="-1" href="#threading">Threading</a></li>
<li><a tabindex="-1" href="#exercises">Exercises</a></li>

						</ul>
					</div>
					<div class="col-lg-9 col-md-9">
						<html><head /><body><div><div class="page-header"><h1>Session 7 (02/12/2021)</h1></div>
<h2 id="summary">Summary</h2>
<p>This lab covers some of the more complex C++ features: pointers to member
functions and more elaborate uses of <span class="label&#10;label-danger">C++11</span> lambda functions. We wrap up with a gentle
introduction to C++ multithreading and two exercises.</p>
<h2 id="pointerstomemberfunctions">Pointers to member functions</h2>
<h3>Different from regular function pointers?</h3>
<p>In the beginning of this C++ course (<a href="session_02.html">session 2</a>) you studied
<strong>function pointers</strong> and other related subjects like <strong>functors</strong> and
<strong>polymorphic function wrappers</strong>. You might have noticed that although a
<strong>function</strong> and a <strong>functor</strong> could behave very similarly, the functor <strong>needs
an object</strong> to be called on. Therefore, even if the arguments and return value
are identical, you can't assign one to the other. For example:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

using namespace std;

class Ftor {
    public:
        int operator()(int a, int b) {
            return a + b;
        }
};

int func(int a, int b) {
    return a + b;
}

// Shorthand notation for a function with the above signature, C++11 alias declaration!
using binary_funct_t = int (*)(int, int);

int main(int argc, char* argv[]) {
    int a = 1;
    int b = 2;
    Ftor ftor; // You need an object to call Ftor::operator()

    // Function and functor behave the same
    cout &lt;&lt; func(a, b) &lt;&lt; endl;
    cout &lt;&lt; ftor(a, b) &lt;&lt; endl;

    // But they don't have the same type
    binary_func_t gunc = func; // OK
    binary_func_t gtor = ftor.operator(); // ERROR!

    // All the rest is wishful thinking...
    cout &lt;&lt; gunc(a, b) &lt;&lt; endl;
    cout &lt;&lt; gtor(a, b) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Play around with the above code. You'll get errors such as:</p>
<pre class="prettyprint"><code>error: cannot convert 'Ftor::operator()' from type 'int (Ftor::)(int, int)'
    to type 'binary_func_t {aka int (*)(int, int)}'
</code></pre>
<!-- class to a pointer to a member of a derived class. Not the other way around! -->

<div class="alert alert-success">
<p><strong>Alias declarations</strong>: noticed how I used a <span class="label&#10;label-danger">C++11</span> alias declariation for binary_funct_t? If you want to progam old-school (but you shouldn't), you could have used C++98 <code>typedef</code>. In the next session you will learn why alias declarations should be preferred over <code>typedef</code>.</p>
</div>
<h3>Syntax</h3>
<p>The function <code>func</code> is of the type <code>int (*)(int, int)</code> whereas
<code>Ftor::operator()</code> has the type <code>int (Ftor::*)(int, int)</code>; it's a <strong>pointer to
a member function</strong> of <code>Ftor</code> and needs an object of type <code>Ftor</code> to be called
on; this won't work:</p>
<pre class="prettyprint"><code>// Define g to be a pointer to a member function of Ftor with two int
// arguments. Assign Ftor's operator() to g
int (Ftor::* g)(int, int);
g = &amp;Ftor::operator();

// Try to call g
cout &lt;&lt; g(a, b) &lt;&lt; endl;
</code></pre>
<p>You'll have to do this instead:</p>
<pre class="prettyprint"><code>int (Ftor::* g)(int, int);
g = &amp;Ftor::operator();

Ftor gtor; // &lt;- You NEED an existing object to call g on
// ... and this is the one and only right syntax to do so
cout &lt;&lt; (gtor.*g)(a, b) &lt;&lt; endl;
</code></pre>
<p>Or, if <code>gtor</code> is a pointer to an object of type <code>Ftor</code>:</p>
<pre class="prettyprint"><code>Ftor* gtor = new Ftor;
cout &lt;&lt; (gtor-&gt;*g)(a, b) &lt;&lt; endl;
</code></pre>
<p>Note that if you use the <strong>polymorphic function wrapper</strong> from <code>#include
&lt;functional&gt;</code> both the function and the functor can be wrapped properly:</p>
<pre class="prettyprint"><code>function&lt;int (int, int)&gt; gunc = func;
function&lt;int (int, int)&gt; gtor = ftor;

cout &lt;&lt; gunc(a, b) &lt;&lt; endl;
cout &lt;&lt; gtor(a, b) &lt;&lt; endl;
</code></pre>
<h3>Another example</h3>
<p>Of course the above is <strong>not limited to functors; all (non-static) member
functions behave this way</strong>. Here's another example:</p>
<pre class="prettyprint"><code>class SimpleMath {
    public:
        double sin(double);
        double cos(double);
        ...
};

// Define a pointer to member of SimpleMath
// which takes and returns a double
double (SimpleMath::* pSimpleMathFunc)(double);
pSimpleMathFunc = &amp;SimpleMath::cos;

// You NEED an object to call the actual function
SimpleMath sm;
double x = (sm.*pSimpleMathFunc)(2.0);

// or a pointer to an object
SimpleMath* pSm = ...
double y = (pSm-&gt;*pSimpleMathFunc)(1.0);
</code></pre>
<h3>Inheritance</h3>
<p>To make matters even more complex pointers to member functions can be used in
the context of derived classes as well. Here's an example:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

using namespace std;

class Base {
    public:
        virtual void print_info() const {
            cout &lt;&lt; "I'm a Base object" &lt;&lt; endl;
        }
};

class Derived : public Base {
    public:
        virtual void print_info() const {
            cout &lt;&lt; "I'm a Derived object" &lt;&lt; endl;
        }
};

int main(int argc, char* argv[]) {

    using BaseMemFun_t = void (Base::*)() const;

    BaseMemFun_t pBMF = &amp;Base::print_info;

    // Calling pBMF on a Base object
    Base b;
    (b.*pBMF)();

    // Calling pBMF on a Derived object
    Derived d;
    (d.*pBMF)();

    // Calling pBMF on a pointer to a Base object
    Base * pb = new Derived;
    (pb-&gt;*pBMF)();

    return 0;
}
</code></pre>
<p>As you would expect, you can't go the other way around and try to call a
pointer to a member of <code>Derived</code> on an instance of <code>Base</code>. <strong>This would require
an implicit downcast in the class hierarchy.</strong> But one can safely assign a pointer to a member of a base
class to a pointer to a member of a derived class.</p>
<!---
As you would expect, you can't go the other way around and try to call a
pointer to a member of `Derived` on an instance of `Base`. **This would require
an implicit downcast in the class hierarchy.** This is called **contravariance**.

> **Contravariance**: one can safely assign a pointer to a member of a base
class to a pointer to a member of a derived class. Not the other way around!
--->

<pre class="prettyprint"><code>using BaseMemFun_t = void (Base::*)() const;
using DerivedMemFun_t = void (Derived::*)() const;

BaseMemFun_t pBMF = &amp;Base::print_info;
DerivedMemFun_t pDMF = pBMF; // OK

// Calling a Base member func. on a pointer to a Derived object
Derived * pd = new Derived;
(pd-&gt;*pDMF)();

// Calling a Derived member func. on a pointer to a Base object
Base * pb = new Derived;
(pb-&gt;*pDMF)();

// Calling a Derived member func. on a pointer to a Base object
Base * pb2 = new Base;
(pb2-&gt;*pDMF)();
</code></pre>
<p>Gives:</p>
<pre class="prettyprint"><code>error: pointer to member type 'void (Derived::)()const' incompatible with
       object type 'Base'
     (pb-&gt;*pDMF)();
           ^
error: pointer to member type 'void (Derived::)()const' incompatible with
       object type 'Base'
     (pb2-&gt;*pDMF)();
            ^
</code></pre>
<h3>Remarks</h3>
<ul>
<li>Pointers to member functions are a <strong>pretty complicated subject</strong> that can
  generate <strong>very hairy compiler error messages</strong>. They are not used that
frequently since there are often better and more clear ways to express similar
functionality using, for instance, <code>std::function</code> objects.</li>
<li>Remember: a member function is <strong>meaningless</strong> without an object to invoke
  on!  Member function pointers cannot be dereferenced (have their function
called) directly by themselves; they <strong>need an object</strong> to operate on.</li>
<li>Use <code>using</code>  (alias declarations) for more clarity: <code>using SMFunc = double (SimpleMath::*)(double)</code>. This allows you to do: <code>SMFunc f = &amp;SimpleMath::sin</code>.</li>
<li>Read: <a href="https://isocpp.org/wiki/faq/pointers-to-members">C++FAQ: Pointers to member
functions</a></li>
<li>Read: <a href="http://yosefk.com/c++fqa/function.html">C++FQA: Pointers to member
functions</a></li>
</ul>
<h2 id="lambdafunctions">Lambda functions</h2>
<p>In <a href="session_02.html#functionscstyle">session 2</a> you already saw an introduction
to <span class="label label-danger">C++11</span> <strong>lambda</strong> or <strong>anonymous</strong>
functions.  Here's some more info about lambda functions.</p>
<p>Although many things can be omitted, the general syntax of lambda functions is:</p>
<pre class="prettyprint"><code>[capture](arguments) -&gt; return_type {/* body */}
</code></pre>
<p>A simple example would be:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

using namespace std;

int main(int argc, char* argv[]) {
    auto f = []() -&gt; void {
        cout &lt;&lt; "Greetings from lambdaland!" &lt;&lt; endl;
    };

    f();

    return 0;
}
</code></pre>
<p>In many cases the return type can be omitted:</p>
<pre class="prettyprint"><code>auto f = []() {
    cout &lt;&lt; "Greetings from lambdaland!" &lt;&lt; endl;
};
</code></pre>
<div class="alert alert-success">
<p>OK, I lied! Actually the standard says: "specify return type explicitly when
lambda is more than <strong>JUST ONE return statement</strong>". However, neither GCC not
Clang++ will complain if you omit it in the above cases.</p>
</div>
<h3>Capture</h3>
<p>The above lambda function has <strong>no capture</strong>: it has no access to variables
outside its scope. Suppose we'd want to do this:</p>
<pre class="prettyprint"><code>const double pi = 3.14159265;
auto f = []() {
    cout &lt;&lt; "I want pi! " &lt;&lt; pi &lt;&lt; endl;
};

f();
</code></pre>
<p>Computer says <strong>NO</strong>:</p>
<pre class="prettyprint"><code>error: 'pi' is not captured
     cout &lt;&lt; "I want pi! " &lt;&lt; pi &lt;&lt; endl;
                              ^
</code></pre>
<h4>Capture all by value</h4>
<p>To give the lambda access to its "surrounding" scope we can set the default
capture to <strong>by value</strong> using <code>[=]</code>:</p>
<pre class="prettyprint"><code>const double pi = 3.14159265;
auto f = [=]() {
    cout &lt;&lt; "I want pi! " &lt;&lt; pi &lt;&lt; endl;
};

f();
</code></pre>
<p>In which case the lambda accesses a local <strong>copy</strong> of <code>pi</code> (and any other
variables that are used in the lambda) <strong>No changes to that local copy are
permitted</strong>: you will get messages like <code>error: assignment of read-only
variable 'pi'</code>.</p>
<h4>Capture all by reference</h4>
<p>If you want to be able to change the values of the captured variables you need
to <strong>capture by reference</strong> using <code>[&amp;]</code>:</p>
<pre class="prettyprint"><code>string msg = "Hello";
auto f = [&amp;]() {
    msg += " from lambda!";
};

cout &lt;&lt; msg &lt;&lt; endl;
f();
cout &lt;&lt; msg &lt;&lt; endl;
</code></pre>
<p>which of course gives:</p>
<pre class="prettyprint"><code>Hello
Hello from lambda!
</code></pre>
<h4>Explicit capture</h4>
<p>If you need more fine grained control over what gets captured and how, you can
<strong>explicitly</strong> name the captured variables:</p>
<pre class="prettyprint"><code>const double pi = 3.14159265;
string msg = "Hello";

auto f = [&amp;msg, pi]() {
    cout &lt;&lt; "I want pi! " &lt;&lt; pi &lt;&lt; endl;
    msg += " from lambda!";
};

cout &lt;&lt; msg &lt;&lt; endl;
f();
cout &lt;&lt; msg &lt;&lt; endl;
</code></pre>
<p>In such cases, accessing anything else than <code>msg</code> and <code>pi</code> within the lambda is
an error.</p>
<div class="alert alert-success">
<p>When using the lambda capture, keep in mind some of its <a href="http://stackoverflow.com/questions/34568183/disadvantage-of-using-lambda-default-capture-by-value-or-reference-in-c11">pitfalls</a>, such as dangling references and dangling pointers.</p>
</div>
<h4>Type of lambda expressions</h4>
<p>In case you might wonder what hides behind the <code>auto</code> type we're using in the
previous examples you can try the following little experiment:</p>
<pre class="prettyprint"><code>int main(int argc, char* argv[]) {
    const double pi = 3.14159265;
    string msg = "Hello";

    auto f = [&amp;]() {
        msg += " from lambda!";
    };

    auto g = [=]() {
        cout &lt;&lt; "I want pi! " &lt;&lt; pi &lt;&lt; endl;
    };

    cout &lt;&lt; typeid(f).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(g).name() &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Compiling with GCC (7.3) gives:</p>
<pre class="prettyprint"><code>Z4mainEUlvE_
Z4mainEUlvE0_
</code></pre>
<p>These are <em>mangled</em> symbol names. To decode (<em>unmangle</em>) them, use the
<code>c++filt</code> command line tool: <code>./my_program | c++filt -t</code>:</p>
<pre class="prettyprint"><code>main::{lambda()#1}
main::{lambda()#2}
</code></pre>
<div class="alert alert-success">
<p>Symbol names of lambda expressions are not defined by the standard and are
thus compiler-dependent. For instance, on Clang 3.3 I get: <code>main::$_0</code> and
<code>main::$_1</code>.</p>
</div>
<p>Notice that even though they share the same signature (capture doesn't play a
role here, you can try if you want) the two lambdas have a <strong>different type</strong>.
<strong>ALL</strong> lambdas have their own <strong>unique type</strong>.</p>
<p>Because of the above, C++ does not allow you to define a <code>vector</code> of lambdas.
For such purposes you should wrap lambdas with a polymorphic function wrapper:</p>
<pre class="prettyprint"><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;

int main(int argc, char* argv[]) {
    const double pi = 3.14159265;
    string msg = "Hello";

    auto f = [&amp;]() {
        msg += " after lambda!";
    };

    auto g = [=]() {
        cout &lt;&lt; "I want pi! " &lt;&lt; pi &lt;&lt; endl;
    };

    vector&lt;function&lt;void ()&gt;&gt; fs = {f, g};

    for (auto f : fs) {
        cout &lt;&lt; msg &lt;&lt; endl;
        f();
        cout &lt;&lt; msg &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<h4>Lambdas and the <code>std</code> algorithms</h4>
<p>In many cases, for instance sorting with <code>std::sort</code>, you can define your own
"comparators" to alter the default behavior of <code>std</code> algorithms or to allow the
algorithms to run on user-defined types. For example, the predefined <code>operator&lt;</code>
for <code>std::string</code> results in alphabetical sorting.</p>
<p>If you would like to use some other way to sort elements, you can pass your own
string comparator as a lambda function to the <code>std::sort</code> routine:</p>
<pre class="prettyprint"><code>vector &lt;string&gt; v;
v.push_back("Lorem");
v.push_back("ipsum");
v.push_back("dolor");
v.push_back("sit");
v.push_back("amet");

// Sort vector by string length
sort(v.begin(), v.end(), [](string a, string b)-&gt;bool {
    return a.length() &lt; b.length();
});

for (string s : v) {
    cout &lt;&lt; s &lt;&lt; endl;
}
</code></pre>
<p>Before <span class="label label-danger">C++11</span> you'd need to define a
separate function of functor to achieve this.</p>
<h4>Reading material</h4>
<ul>
<li><a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html">Cprogramming.com: lambda functions in C++11</a></li>
</ul>
<h2 id="threading">Threading</h2>
<p><span class="label label-danger">C++11</span> introduces basic facilities for
threading in the standard library. "Basic" in this case means that threads are
handled in a pretty low-level manner with no scheduling or any implicit thread
safety.</p>
<p>Note that on some systems, to run this thread functionality you'll have to add the following flag:</p>
<pre class="prettyprint"><code>SET(CMAKE_CXX_FLAGS -pthread)
</code></pre>
<p>Have a look at the following examples.</p>
<h3>Example 0</h3>
<pre class="prettyprint"><code>#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

// The function that will be called in a separate thread
void thread_func() {
    cout &lt;&lt; "Hello from thread " &lt;&lt; this_thread::get_id() &lt;&lt; endl;
}

int main(int argc, char* argv[]) {
    // Launch one thread that will execute the code of thread_func
    thread t1(thread_func);
    thread t2(thread_func);

    // Wait for the thread to finish
    t1.join();
    t2.join();

    return 0;
}
</code></pre>
<h3>Example 1</h3>
<pre class="prettyprint"><code>#include &lt;iostream&gt;
#include &lt;thread&gt;

using namespace std;

int main(int argc, char* argv[]) {
    // Launch one thread that will execute the code of the lambda
    thread t([](){
        cout &lt;&lt; "Hello from thread " &lt;&lt; this_thread::get_id() &lt;&lt; endl;
    });

    // ... Do other stuff while thread t is busy

    // Wait for the thread to finish
    t.join();

    return 0;
}
</code></pre>
<h3>Example 2</h3>
<p>What goes wrong here? Make sure to request many threads.</p>
<pre class="prettyprint pre-scrollable"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

using namespace std;

void thrFunc(int&amp; a) {
    ++a;
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        cout &lt;&lt; argv[0] &lt;&lt; " num_threads" &lt;&lt; endl;
        return 1;
    }
    int num_threads = atoi(argv[1]);

    // Accumulator
    int a = 0;

    // Create &amp; launch some threads
    vector&lt;thread*&gt; threads;
    for (size_t idx = 0; idx &lt; num_threads; ++idx) {
        threads.push_back(new thread(thrFunc, ref(a)));
    }

    // "Barrier"
    for (thread * t : threads) {
        t-&gt;join();
    }

    if (a == num_threads) {
        cout &lt;&lt; "OK!" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "What?? a is " &lt;&lt; a &lt;&lt; ", should be " &lt;&lt; num_threads &lt;&lt; endl;
    }

    // Cleanup
    for (thread * t : threads) {
        delete t;
    }

    return 0;
}
</code></pre>
<h3>Example 3</h3>
<pre class="prettyprint pre-scrollable"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

using namespace std;

void thrFunc(int&amp; a, mutex&amp; a_mtx) {
    a_mtx.lock();
    ++a;
    a_mtx.unlock();
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        cout &lt;&lt; argv[0] &lt;&lt; " num_threads" &lt;&lt; endl;
        return 1;
    }
    int num_threads = atoi(argv[1]);

    // Accumulator &amp; its mutex
    int a = 0;
    mutex a_mtx;

    // Create &amp; launch some threads
    vector&lt;thread*&gt; threads;
    for (size_t idx = 0; idx &lt; num_threads; ++idx) {
        threads.push_back(new thread(thrFunc, ref(a), ref(a_mtx)));
    }

    // "Barrier"
    for (thread * t : threads) {
        t-&gt;join();
    }

    if (a == num_threads) {
        cout &lt;&lt; "OK!" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "What?? a is " &lt;&lt; a &lt;&lt; ", should be " &lt;&lt; num_threads &lt;&lt; endl;
    }

    // Cleanup
    for (thread * t : threads) {
        delete t;
    }

    return 0;
}
</code></pre>
<div class="alert alert-success">
<p><span class="label label-danger">C++11</span> also introduced an <a href="http://en.cppreference.com/w/cpp/atomic/atomic">atomic operations library</a> with which you can solve this problem. Can you rewrite the code so you would not need mutex?</p>
</div>
<h3>Reading material</h3>
<p>Please read the following material:</p>
<ul>
<li><a href="http://www.codeproject.com/Articles/598695/Cplusplus11-threads-locks-and-condition-variables">C++11 threads, locks and condition variables</a></li>
<li><a href="http://solarianprogrammer.com/2011/12/16/cpp-11-thread-tutorial/">C++11 multithreading tutorial</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread">Cppreference: threading</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<h3>Looking four trouble?</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/TftKOZq1">https://classroom.github.com/a/TftKOZq1</a></p>
<h3>Parallel <code>daxpy</code></h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/8F5bcjAz">https://classroom.github.com/a/8F5bcjAz</a></p>
<h3>Vlaamse Programmeerwedstrijd: Lichtspiegeling opgave</h3>
<p>De opgave van deze week bestaat erin te beoordelen of lichstralen op een correcte manier weerkaatst worden. Je kan de volledige opgave <a href="http://www.vlaamseprogrammeerwedstrijd.be/2011/opgaves/cat2-2011/lichtspiegeling.pdf">hier</a> vinden. De officiele testinvoer moet je dit keer uit de opgave halen en de <a href="http://www.vlaamseprogrammeerwedstrijd.be/2011/opgaves/cat2-2011/lichtspiegeling/wedstrijd.input">wedstrijdinvoer</a> en <a href="http://www.vlaamseprogrammeerwedstrijd.be/2011/opgaves/cat2-2011/lichtspiegeling/wedstrijd.output">-uitvoer</a>. Succes!</p></div></body></html>
					</div>
				</div>
			</div>

			<div class="footer">
				<p class="text-muted">&copy; <a href="mailto:glenn.daneels@uantwerpen.be">Glenn Daneels</a> / <a href="mailto:przemyslaw.klosiewicz@uantwerpen.be">Przemyslaw Klosiewicz</a> / IDLab / Universiteit Antwerpen.</p>
			</div>
		</div>

		<script src="http://code.jquery.com/jquery.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/google-code-prettify/prettify.js"></script>
	</body>
</html>
