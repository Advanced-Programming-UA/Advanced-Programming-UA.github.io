<!DOCTYPE html>
<html lang="en">
	<head>
		<title>C++ lab sessions</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<style type="text/css">
			body {
				padding-top: 70px;
			}
			.footer {
				border-top: 1px solid #eee;
				margin-top: 20px;
				padding-top: 20px;
				padding-bottom: 10px;
			}
			h2 {
				padding-top: 60px;
			}
		</style>
		<!-- Google prettify -->
		<link href="js/google-code-prettify/my-prettify.css" rel="stylesheet">
		<!--<link href="http://twitter.github.io/bootstrap/assets/js/google-code-prettify/prettify.css" rel="stylesheet">-->
	</head>
	<body onLoad="prettyPrint()" data-spy="scroll" data-target="#subnavigation">
		<div class="container">
			<div class="navbar navbar-default navbar-fixed-top hidden-print">
				<div class="container">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
					</div>
					<div class="navbar-collapse collapse">
						<ul class="nav navbar-nav">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									C++ lab sessions
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<li><a tabindex="-1" href="index.html">Overview</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="session_00.html">Session 0 (05/10/2023)</a></li>
<li><a tabindex="-1" href="session_01.html">Session 1 (12/10/2023)</a></li>
<li><a tabindex="-1" href="session_02.html">Session 2 (19/10/2023)</a></li>
<li><a tabindex="-1" href="session_03.html">Session 3 (02/11/2023)</a></li>
<li><a tabindex="-1" href="session_04.html">Session 3 (02/11/2023)</a></li>
<li><a tabindex="-1" href="session_05.html">Session 4 (08/11/2023)</a></li>
<li><a tabindex="-1" href="session_06.html">Session 5 (16/11/2023)</a></li>
<li><a tabindex="-1" href="session_07.html">Session 7 (30/11/2023)</a></li>
<li class="active"><a tabindex="-1" href="session_08.html">Session 8 (07/12/2023)</a></li>
<li><a tabindex="-1" href="session_09.html">Session 9 (14/12/2023)</a></li>

								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									Quick links
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<!-- Hard coded links to useful sites, open in new tab -->
									<li><a tabindex="-1" href="http://www.cplusplus.com/" target="_blank">cplusplus.com</a></li>
									<li><a tabindex="-1" href="http://en.cppreference.com/" target="_blank">cppreference.com</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://www.cmake.org/Wiki/CMake_FAQ" target="_blank">CMake documentation</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://git-scm.com/book" target="_blank">Git documentation</a></li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</div>

			<div class="container">
				<div class="row">
					<!-- Subnav bar is only visible on large devices -->
					<div id="subnavigation" class="col-lg-3 col-md-3 visible-md visible-lg hidden-print">
						<ul class="nav nav-pills nav-stacked" style="position: fixed">
							<h3>Jump to:</h3>
							<li><a tabindex="-1" href="#summary">Summary</a></li>
<li><a tabindex="-1" href="#genericprogramming">Generic programming</a></li>
<li><a tabindex="-1" href="#functiontemplates">Function templates</a></li>
<li><a tabindex="-1" href="#aliastemplates">Alias templates</a></li>
<li><a tabindex="-1" href="#exercises">Exercises</a></li>

						</ul>
					</div>
					<div class="col-lg-9 col-md-9">
						<html><head /><body><div><div class="page-header"><h1>Session 8 (07/12/2023)</h1></div>
<h2 id="summary">Summary</h2>
<p>This lab session is entirely dedicated to the subject of C++ <strong>function templates</strong>.
It's no exaggeration to say that templates are a very advanced topic.
However, the introduction of templates to C++ in 1989 was a huge step towards the development of <strong>generic containers and algorithms</strong> in C++.
A couple of examples and exercises should get you started.</p>
<h2 id="genericprogramming">Generic programming</h2>
<p>Using templates allows you to reuse source code: one piece of code can be reused in multiple formats.
More specifically, the C++ template mechanism allows you to use a type as a parameter for a definition of a function or a class; these are the so-called <em>templates arguments</em>.
This results in so-called <em>class templates</em> and <em>function templates</em>.
Keep in mind: the template mechanism of C++ happens at compile time in contradiction to the run-time based polymorphism OOP with late binding.
In this session, we'll start with function templates.</p>
<h2 id="functiontemplates">Function templates</h2>
<h3>Basics</h3>
<p><em>Function templates</em> are a key feature in C++ for writing generic functions that can be called with arguments of different types to perform functionality that's analogous for these different types.
A good example is <strong>sorting</strong> a sequence; it's not important what's being sorted exactly.
The only thing that's necessary is an operation to compare two objects of the same type; for instance </p>
<pre class="prettyprint"><code>bool T::operator&lt;(const T &amp;) const;
</code></pre>
<p>where <code>T</code> denotes a generic type.</p>
<p>In this sense, a function template acts as a <strong>pattern</strong> used by the compiler to generate (<strong>instantiate</strong>) a family of functions depending on the type of the arguments they're called with. 
For function templates this instantiation can happen in two ways:</p>
<ul>
<li>using <strong>explicit instantiation</strong>: explicitly stating the type arguments.</li>
<li>using <strong>argument deduction</strong>: deducing the type arguments from the static types of the call arguments.</li>
</ul>
<p>Remember: A <em>template function</em> is an <strong>instantiation</strong> of a <em>function template</em>.</p>
<p>The basic syntax of defining a function template is:</p>
<pre class="prettyprint"><code>template&lt;typename T&gt;
void sort(std::vector&lt;T&gt; &amp; v) {
    // use:
    // bool T::operator&lt;(const T &amp;) const;
    // if available, to compare and sort
    // objects of type T
}
</code></pre>
<p>If the argument list uniquely identifies the set of template arguments the type
of function arguments can be <strong>deduced</strong> from the call:</p>
<pre class="prettyprint"><code>std::vector&lt;int&gt; v;
...
sort(v);
</code></pre>
<p>In other cases <a href="https://isocpp.org/wiki/faq/templates#fn-templates-explicit-calls">explicit instantiation</a> is necesary:</p>
<pre class="prettyprint"><code>sort&lt;int&gt;(v);
</code></pre>
<p>Please note that since the <strong>compiler does not know</strong> what type will be used as
<code>T</code> <strong>no code</strong> is generated for a function template. The code for a template
function is generated at the moment of its instantiation with a concrete type.</p>
<p>Template arguments can be <strong>built-in types</strong> or a <strong>user-defined types</strong>. Of course, statements and expressions in the function template body should be valid and defined on the type. For example:</p>
<pre class="prettyprint"><code>template&lt;typename T&gt;
T min(const T &amp; a, const T &amp; b) {
  if (a &lt; b)
      return a;
  else
      return b;
}
</code></pre>
<p>Call it with <code>int</code> and <code>Foo</code>:</p>
<pre class="prettyprint"><code>min(4,5);         // OK

Foo foo1;         // Foo is an user-defined empty class, with no member variables nor functions
Foo foo2;         // Foo is an user-defined empty class, with no member variables nor functions
min(foo1, foo2);  // COMPILE ERROR
</code></pre>
<p>Trying to instantiate <code>min</code> with <code>Foo</code> min with <code>foo1</code> and <code>foo2</code> returns this error:</p>
<pre class="prettyprint"><code>main.cpp: In instantiation of 'T min(const T&amp;, const T&amp;) [with T = Foo]':
main.cpp:35:51:   required from here
main.cpp:25:11: error: no match for 'operator&lt;' (operand types are 'const Foo' and 'const Foo')
     if (a &lt; b)
</code></pre>
<p><code>Foo</code> does not have an overload definition of <code>&lt;</code> which prohibits the compiler from instantiating the <code>min</code> for the <code>Foo</code> template argument.</p>
<div class="alert alert-success">
<p>Sometimes you see the keyword <code>class</code> being used instead of <code>typename</code>. 
When naming template parameters, there are equivalent. 
<code>typename</code> is however also possible in another context related to templates. 
Read about it <a href="http://stackoverflow.com/questions/2023977/c-difference-of-keywords-typename-and-class-in-templates">here</a>.</p>
</div>
<h3>Instantiation</h3>
<p>You can see that no code gets generated for a template unless it's instantiated for a specific type with the following little experiment:</p>
<p><code>print.h</code>:</p>
<pre class="prettyprint"><code>#ifndef PRINT_H
#define PRINT_H

template&lt;typename T&gt;
void print(const T &amp; x);

#endif /* PRINT_H */
</code></pre>
<p><code>print.cpp</code>:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;
#include "print.h"

template&lt;typename T&gt;
void print(const T &amp; x) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}
</code></pre>
<p>Now create a <code>main.cpp</code> file that includes the <code>print.h</code> file but does not use the <code>print</code> function:</p>
<pre class="prettyprint"><code>#include "print.h"

int main() {
    int i = 3;
    return 0;
}
</code></pre>
<p>Compile &amp; link the above code: <code>g++ -o p main.cpp print.cpp</code> and look at the symbols defined in the generated executable: <code>nm p | c++filt</code>:</p>
<pre class="prettyprint"><code>0000000100000ee3 unsigned short __GLOBAL__sub_I_print.cpp
0000000100000e9b unsigned short __static_initialization_and_destruction_0(int, int)
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
0000000100001030 short std::__ioinit
                 U ___cxa_atexit
0000000100000000 T __mh_execute_header
0000000100000e89 T _main
                 U dyld_stub_binder
</code></pre>
<p>There's no mention of <code>print</code> whatsoever!</p>
<p>You can try to call the <code>print</code> function in <code>main.cpp</code>:</p>
<pre class="prettyprint"><code>#include "print.h"

int main() {
    int i = 3;
    print(i);
    return 0;
}
</code></pre>
<p>Unfortunately you'll get a linker error:</p>
<pre class="prettyprint"><code>Undefined symbols for architecture x86_64:
  "void print&lt;int&gt;(int const&amp;)", referenced from:
      _main in cc1bl7rY.o
ld: symbol(s) not found for architecture x86_64
collect2: error: ld returned 1 exit status
</code></pre>
<p>Since <code>print.cpp</code> and <code>main.cpp</code> are compiled as two separate translation units the compiler can not generate code for the <code>print</code> function.
While compiling <code>print.cpp</code> it does not know that some other code is using <code>print&lt;int&gt;</code> and can not generate code for <code>print</code> with an unknown type <code>T</code>.
On the other hand, when compiling <code>main.cpp</code> the compiler supposes that a <code>print&lt;int&gt;</code> is defined somewhere else and that's why linking fails.</p>
<p>There are several possibilities to make things work here:</p>
<h4>Implementation in the header file</h4>
<p>Header files should normally only contain function declarations, but <em>function (or class) templates</em> are an exception to this.
The actual <em>template function</em> definition is generated when the template is instantiated, which should be done in a source file, thereby not violating the <strong>one-definition-rule</strong>.
But be careful not to define anything else besides templates in the header file!
By including the <em>recipe</em> in the header file, every translation unit that uses your template knows how instantiate it for the types they require.</p>
<h4>Explicit instantiation</h4>
<p>Instantiate the template for the specific type that you need within <strong>the same translation unit</strong> as the template <strong>definition</strong>, i.e., in <code>print.cpp</code>:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;
#include "print.h"

// Template definition
template&lt;typename T&gt;
void print(const T &amp; x) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}

// Explicit instantiation of print&lt;T&gt; for T = int
template void print&lt;int&gt;(const int &amp; x);
</code></pre>
<p>Now <code>print</code> is generated:</p>
<pre class="prettyprint"><code>0000000100001e8b unsigned short __GLOBAL__sub_I_print.cpp
0000000100001e42 unsigned short __static_initialization_and_destruction_0(int, int)
0000000100001e07 T void print&lt;int&gt;(int const&amp;)
                 U std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))
                 U std::ostream::operator&lt;&lt;(int)
                 U std::ios_base::Init::Init()
                 U std::ios_base::Init::~Init()
                 U std::cout
                 U std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;)
0000000100002050 short std::__ioinit
                 U ___cxa_atexit
0000000100000000 T __mh_execute_header
0000000100001de5 T _main
                 U dyld_stub_binder
</code></pre>
<p>However, this is not very convenient because you need to alter the template's <code>.cpp</code> file to specify which template instantiations you'll need beforehand.
Note that if you explicitly instantiate the template in a translation unit where the template definition is not known, <code>main.cpp</code> for instance, does not work. Thus, doing this:</p>
<pre class="prettyprint"><code>#include "print.h"

template void print&lt;int&gt;(const int &amp; x);

int main() {
    int i = 3;
    print(i);
    return 0;
}
</code></pre>
<p>results in this:</p>
<pre class="prettyprint"><code>main.cpp: In instantiation of 'void print(const T&amp;) [with T = int]':
main.cpp:3:39:   required from here
main.cpp:3:39: error: explicit instantiation of 'void print(const T&amp;) [with T = int]' but no definition available [-fpermissive]
 template void print&lt;int&gt;(const int &amp; x);
                                       ^
</code></pre>
<h4>The <code>extern</code> keyword</h4>
<p>This feature allows you to reduce the work done by the compiler by using the <em>already constructed</em> instantiations of the templates. Have a look at:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/8130602/using-extern-template-c0x/8131212#8131212">Stackoverflow answer</a> (also read the comments on the answer: the author of the answers forgot something...)</li>
<li><a href="https://isocpp.org/wiki/faq/cpp11-language-templates#extern-templates">C++FAQ</a></li>
</ul>
<h3>Argument deduction</h3>
<p>Let's go back to template argument deduction.
When the template mechanism needs argument conversion to map the call to the template signature, the compiler will generate a fatal error because of the possible ambiguity.
For example, following <code>print</code> function with two parameters:</p>
<pre class="prettyprint"><code>template&lt;typename T&gt;
void print(const T &amp; x, const T &amp; y) {
  std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;
}
</code></pre>
<p>Calling the <code>print</code> like this:</p>
<pre class="prettyprint"><code>print(3, 5.0);
</code></pre>
<p>results in:</p>
<pre class="prettyprint"><code>main.cpp: In function 'int main()':
main.cpp:11:17: error: no matching function for call to 'print(int, double)'
     print(3, 5.0);
                 ^
main.cpp:5:27: note: candidate: template&lt;class T&gt; void print(const T&amp;, const T&amp;)
 template&lt;typename T&gt; void print(const T &amp; x, const T &amp; y) {
                           ^~~~~
main.cpp:5:27: note:   template argument deduction/substitution failed:
main.cpp:11:17: note:   deduced conflicting types for parameter 'const T' ('int' and 'double')
     print(3, 5.0);
</code></pre>
<p>The compiler does not want to decide on the conversion and fails. 
This problem can be resolved by <strong>explicitly</strong> stating the template argument. This way the compilers knows which conversion to apply.</p>
<pre class="prettyprint"><code>print&lt;int&gt;(3, 5.0);
</code></pre>
<p>When using multiple template parameters, one can also apply <strong>partial argument deduction</strong>.
Here, the arguments that should be deduced should be placed at the end of the argument list.
Having a <code>print</code> with two different template parameters:</p>
<pre class="prettyprint"><code>template&lt;typename U, typename T&gt;
void print(const U &amp; x, const T &amp; y) {
  std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;
}
</code></pre>
<p>One can call this <code>print</code> as follows:</p>
<pre class="prettyprint"><code>print&lt;double&gt;(5.0, 4);
</code></pre>
<p>Here, <code>U</code> is determined by the explicit (<code>double</code>) initialization, while <code>T</code> is deduced to being an <code>int</code>.</p>
<h3>Specialization</h3>
<p>If your function template needs a specific implementation for a specific type, such as for instance a <code>std::vector&lt;bool&gt;</code> uses a special implementation (<a href="http://en.cppreference.com/w/cpp/container/vector_bool">read more</a>), you can <strong>specialize</strong> the template:</p>
<p><code>print.h</code>:</p>
<pre class="prettyprint"><code>#ifndef PRINT_H
#define PRINT_H

template&lt;typename T&gt;
void print(const T &amp; x);

#endif /* PRINT_H */
</code></pre>
<p><code>print.cpp</code>:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;
#include "print.h"

// Generic implementation
template&lt;typename T&gt;
void print(const T &amp; x) {
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}

// Specific implementation for T = char
template&lt;&gt;
void print&lt;char&gt;(const char &amp; x) {
    std::cout &lt;&lt; x &lt;&lt; " is a char!" &lt;&lt; std::endl;
}

// Instantiations of print for T = int and T = char
template void print&lt;int&gt;(const int &amp; x);
template void print&lt;char&gt;(const char &amp; x);
</code></pre>
<p>This <em>generic implementation</em> is also called the <strong>primary template</strong> (in the case there are also specializations, otherwise it is just called a template).
The <em>specific implementation</em> is also called an <strong>explicit specialization</strong>.</p>
<p><code>main.cpp</code>:</p>
<pre class="prettyprint"><code>#include "print.h"

// Specific implementation for T = bool
template&lt;&gt;
void print&lt;bool&gt;(const bool &amp; x) {
    std::cout &lt;&lt; x &lt;&lt; " is a bool!" &lt;&lt; std::endl;
}

int main() {
    int i = 3;
    print(i);

    char p = 'P';
    print(p);

    print(true);

    return 0;
}
</code></pre>
<p>We added two explicit specializations: <code>T = char</code> in <code>print.cpp</code>, <code>T = bool</code> in <code>main.cpp</code>.
As you can see from the specialization <code>T = bool</code> in <code>main.cpp</code>, explicit specializations do <strong>not</strong> need the primary template definition: its <strong>declaration is enough</strong> (which is available in <code>print.h</code>).</p>
<p>You might wonder now: what is the practical difference between <strong>function overloading</strong> and <strong>function template specialization</strong>? 
When should I define <code>print(int)</code> instead of specializing the <code>print&lt;T&gt;</code> template for <code>T = int</code>?</p>
<p>You're not the only one confusing the two:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/7108033/template-specialization-vs-function-overloading">StackOverflow</a></li>
<li><a href="http://www.gotw.ca/publications/mill17.htm">Why not specialize function templates?</a></li>
<li>Stroustrup book, 25.3.4.2, "Specialization That is Not Overloading"</li>
</ul>
<h3>Default template arguments</h3>
<p>Just like a function's argument list can specify default values for the arguments making them optional, a function template can specify default values for its template arguments.</p>
<p>This is used a lot in the context of custom comparator objects. In this example, a default comparator <code>CustomComparatorLess</code> is set. 
If we do want to sort the vector in ascending order, we specify the <code>CustomComparatorGreater</code> type as template argument:</p>
<pre class="prettyprint"><code>class CustomComparatorLess {
public:
    bool operator() (const int&amp; i, const int&amp; j) { return (i &lt; j); };
};

class CustomComparatorGreater {
public:
    bool operator() (const int&amp; i, const int&amp; j) { return (i &gt; j); };
};

template&lt;typename C = CustomComparatorLess&gt;
void customSort(std::vector&lt;int&gt;&amp; v) {
    C cmp;
    std::sort(v.begin(), v.end(), cmp);
    for (int val: v)
        std::cout &lt;&lt; val &lt;&lt; std::endl;
};

int main() {
    std::vector&lt;int&gt; v = {3, 6, 4, 5, 1, 6};
    customSort(v);
    customSort&lt;CustomComparatorGreater&gt;(v);

    return 0;
}
</code></pre>
<p>Of course, it would be much nicer if we can not only apply this to <code>vector&lt;int&gt;</code>, but to all kind of <code>vector</code> types.
With the help of class templates (which are discussed in next section) we can make this possible.</p>
<h2 id="aliastemplates">Alias templates</h2>
<p>This handy <span class="label label-danger">C++11</span> feature allows you to define something you could call "typedef templates".
Suppose you'd like to define a matrix-like class as a vector of vectors, you could write</p>
<pre class="prettyprint"><code>std::vector&lt;std::vector&lt;double&gt;&gt; m;
</code></pre>
<p>However, writing this every time you need such a type is extremely inconvenient.
To ease the pain you could create and use a <code>typedef</code> like this:</p>
<pre class="prettyprint"><code>typedef std::vector&lt;std::vector&lt;double&gt;&gt; vv_d_t;
// Now this is much cleaner:
vv_d_t m;
</code></pre>
<p>Although you'd need to define such a <code>typedef</code> for <strong>each type of variables</strong> you want to store in the vectors (hence the <code>d</code> in <code>vv_d_t</code>, a <code>vector</code> of <code>vector</code>s of <code>double</code>s).
What you'd really want is a <code>typedef</code> that can be instantiated for a generic type <code>T</code>.
Prior to <span class="label label-danger">C++11</span> that was not possible.
Now you can do:</p>
<pre class="prettyprint"><code>template&lt;typename T&gt; using vv_t = std::vector&lt;std::vector&lt;T&gt;&gt;;

// Now you can do:
vv_t&lt;double&gt; a;
// and
vv_t&lt;int&gt; b;
</code></pre>
<p>Pretty neat, right? This is the reason that in the <a href="session_07.html#pointerstomemberfunctions">previous session</a> I advised u to always use alias declarations instead of <code>typedef</code>.</p>
<p>The idea of implementing this pretty obvious feature has been around for quite some time already.
You can skim through <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1406.pdf">the original proposal</a> if you want.
For other uses of alias templates have a look <a href="http://en.wikipedia.org/wiki/C++11#Alias_templates">here</a>.</p>
<h3>Further reading material</h3>
<ul>
<li><a href="https://isocpp.org/wiki/faq/templates">C++FAQ on templates</a></li>
<li><a href="http://www.codeproject.com/Articles/257589/An-Idiots-Guide-to-Cplusplus-Templates-Part-1">An Idiot's Guide to C++ Templates</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<h3>Alias Template</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/M_dF-48E">https://classroom.github.com/a/M_dF-48E</a></p>
<h3>Bubble Sort</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/-Swls2Bh">https://classroom.github.com/a/-Swls2Bh</a></p></div></body></html>
					</div>
				</div>
			</div>

			<div class="footer">
				<p class="text-muted">&copy; <a href="mailto:thomas.ave@uantwerpen.be">Thomas Av√©</a> / IDLab / Universiteit Antwerpen.</p>
			</div>
		</div>

		<script src="https://code.jquery.com/jquery.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/google-code-prettify/prettify.js"></script>
	</body>
</html>
