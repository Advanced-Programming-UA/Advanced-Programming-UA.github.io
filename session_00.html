<!DOCTYPE html>
<html lang="en">
	<head>
		<title>C++ lab sessions</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<style type="text/css">
			body {
				padding-top: 70px;
			}
			.footer {
				border-top: 1px solid #eee;
				margin-top: 20px;
				padding-top: 20px;
				padding-bottom: 10px;
			}
			h2 {
				padding-top: 60px;
			}
		</style>
		<!-- Google prettify -->
		<link href="js/google-code-prettify/my-prettify.css" rel="stylesheet">
		<!--<link href="http://twitter.github.io/bootstrap/assets/js/google-code-prettify/prettify.css" rel="stylesheet">-->
	</head>
	<body onLoad="prettyPrint()" data-spy="scroll" data-target="#subnavigation">
		<div class="container">
			<div class="navbar navbar-default navbar-fixed-top hidden-print">
				<div class="container">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
					</div>
					<div class="navbar-collapse collapse">
						<ul class="nav navbar-nav">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									C++ lab sessions
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<li><a tabindex="-1" href="index.html">Overview</a></li>
									<li class="divider"></li>
									<li class="active"><a tabindex="-1" href="session_00.html">Session 0 (06/10/2022)</a></li>

								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									Quick links
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<!-- Hard coded links to useful sites, open in new tab -->
									<li><a tabindex="-1" href="http://www.cplusplus.com/" target="_blank">cplusplus.com</a></li>
									<li><a tabindex="-1" href="http://en.cppreference.com/" target="_blank">cppreference.com</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://www.cmake.org/Wiki/CMake_FAQ" target="_blank">CMake documentation</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://git-scm.com/book" target="_blank">Git documentation</a></li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</div>

			<div class="container">
				<div class="row">
					<!-- Subnav bar is only visible on large devices -->
					<div id="subnavigation" class="col-lg-3 col-md-3 visible-md visible-lg hidden-print">
						<ul class="nav nav-pills nav-stacked" style="position: fixed">
							<h3>Jump to:</h3>
							<li><a tabindex="-1" href="#summary">Summary</a></li>
<li><a tabindex="-1" href="#practicalremarks">Practical remarks</a></li>
<li><a tabindex="-1" href="#helloworld">Hello world</a></li>
<li><a tabindex="-1" href="#compilinglinking">Compiling & linking</a></li>
<li><a tabindex="-1" href="#versioncontrol">Version control</a></li>
<li><a tabindex="-1" href="#codingconventions">Coding conventions</a></li>
<li><a tabindex="-1" href="#exercises">Exercises</a></li>

						</ul>
					</div>
					<div class="col-lg-9 col-md-9">
						<html><head /><body><div><div class="page-header"><h1>Session 0 (06/10/2022)</h1></div>
<h2 id="summary">Summary</h2>
<p>This is the first session in a series of 10 labs covering various aspects of
programming in C++; ranging from the most basic examples to more complicated
topics. Most things covered in the theoretical course notes will be applied
in practice during these sessions. For starters, you'll see an introduction to
the more practical aspects of the labs: setting up the programming environment,
version control, etc.</p>
<h2 id="practicalremarks">Practical remarks</h2>
<p>The <strong>reference platform</strong> for all assignments and projects is the <strong>GNU C++
compiler</strong> installed on the lab computers (including the installed libraries)
which are most probably some recent version of the <a href="http://www.ubuntu.com/">Ubuntu linux
distribution</a>. We advise you to install and use your own standalone Linux system for
development.</p>
<p>The current most up-to-date GNU C++ compiler is <a href="https://gcc.gnu.org">version 12.2.0</a> and for clang <a href="https://clang.llvm.org/">version 14.0.6</a>. You can check the release notes to know exactly which new C++ feature they support. Mac computers usually have their own version of clang installed (based on the open-source clang); probably you'll first have to install Xcode IDE. To install the newest GNU C++ on Mac computers, you can use <a href="https://www.macports.org/">Macports</a> or <a href="http://formulae.brew.sh/repos/Homebrew/homebrew-core/formula/gcc">Homebrew</a>. To check the version of your C++ compiler, do:</p>
<pre class="prettyprint"><code>    g++ --version
</code></pre>
<p>You can use whatever decent text editor that suits your fancy to write code in C++. 
The lab computers include a recent version of <a href="https://www.jetbrains.com/clion/">CLion</a> for programming, code management, debugging and related things.
But the more hardcore terminal users can also find a recent version of <a href="https://www.vim.org/">vim</a> installed.</p>
<div class="alert alert-success">
<p>I assume that you know how to work on the command line interface (CLI, a.k.a. <em>the terminal</em>) in Linux / UNIX-like systems! 
In case you have trouble with that you can find plenty of information online.</p>
</div>
<h2 id="helloworld">Hello world</h2>
<p>Let's dive directly into coding. I am sure you missed it!</p>
<h3>First attempt</h3>
<p>Virtually any programming course starts with the well-known <em>Hello world</em>, so here it is. 
Open up any text editor and create a text file named <code>main.cpp</code> with these contents:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>Compile &amp; link this source file on the command line (make sure you're in the
right directory):</p>
<pre class="prettyprint"><code>g++ -o hw main.cpp
</code></pre>
<p>Finally, run it (in the same directory) to receive a friendly message:</p>
<pre class="prettyprint"><code>./hw
</code></pre>
<h3>Modular code</h3>
<p>An important concept in programming is <strong>modular design</strong>.
I.e. nobody writes all their code in one huge file.
Therefore, split the previous code in two separate files. 
The file <code>hello.cpp</code> contains the <strong>definition</strong> of the function that says hello:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

void hello() {
    std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;
}
</code></pre>
<p>The file <code>main.cpp</code> contains the main entry point of the program (the <code>main</code> function) which calls the <code>hello</code> function defined in the other file and quits afterwards:</p>
<pre class="prettyprint"><code>int main() {
    hello();
    return 0;
}
</code></pre>
<p>Compile &amp; link them:</p>
<pre class="prettyprint"><code>g++ -o hw main.cpp hello.cpp
</code></pre>
<p>This won't work. You'll get an error similar to this one:</p>
<pre class="prettyprint"><code>main.cpp: In function 'int main()':
main.cpp:2:8: error: 'hello' was not declared in this scope
</code></pre>
<p>In human: "Help, I don't know what <code>hello</code> on line 2 in <code>main.cpp</code> means".</p>
<p>The reason for this error is that in C++ every entity (<em>thing</em>) must be <strong>declared</strong> before it can be used within a compilation unit (<em>source file</em>).
We could solve this problem by adding a line in <code>main.cpp</code> that declares the function <code>hello</code> as in:</p>
<pre class="prettyprint"><code>// Declares a function called hello with no return value and no arguments
void hello();

int main() {
    // Now we can call hello(), even though it's defined in hello.cpp
    hello();
    return 0;
}
</code></pre>
<p>Although this would solve the problem in this particular case it won't be a very clean way to do it: you'd have to repeat this for every entity you use in every compilation unit (and remember to update it everywhere if something changes!).</p>
<h3>Header files</h3>
<p>The standard solution is to gather declarations of entities in <strong>header files</strong> and include these using the <code>#include</code> preprocessor directive.
In our example the header file is <code>hello.h</code>:</p>
<pre class="prettyprint"><code>#ifndef HELLO_H
#define HELLO_H

// Declares a function called hello with no return value and no arguments
void hello();

#endif /* HELLO_H */
</code></pre>
<div class="alert alert-success">
<p>The <code>#ifndef</code> block that wraps the contents of the header file is called an <strong>include guard</strong>. 
It prevents the same header file from being included more than once in <strong>one</strong> source file by defining a preprocessor macro (<code>HELLO_H</code> in this case; usually some variation of the header's file name) the first time the file is included. 
If the same header file is included again (through inclusion of other headers that include this particular one, for instance) the <code>#ifndef</code> directive will just skip over the file's contents, since the macro named <code>HELLO_H</code> is already defined.
When used correctly it solves some (not all!) subtle issues with including header files.
Read more about <a href="https://en.wikipedia.org/wiki/Circular_dependency">circular dependencies</a>.</p>
</div>
<p>Now include this header file in both <code>hello.cpp</code>:</p>
<pre class="prettyprint"><code>#include "hello.h"
#include &lt;iostream&gt;

void hello() {
    std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;
}
</code></pre>
<p>and <code>main.cpp</code>:</p>
<pre class="prettyprint"><code>#include "hello.h"

int main() {
    hello();
    return 0;
}
</code></pre>
<p>Compiling &amp; linking should work fine now.
Note that you <strong>don't</strong> compile the header files explicitly.
The code they contain will be included ("copy-pasted") &amp; compiled in the source files that include them.</p>
<pre class="prettyprint"><code>g++ -o hw main.cpp hello.cpp
</code></pre>
<div class="alert alert-success">
<p>Note that although it's not strictly necessary to include <code>hello.h</code> in <code>hello.cpp</code>, it helps if you have many entities in <code>hello.cpp</code> that depend on each other because the order in which you <strong>define</strong> them becomes less important.
It is also a good way of checking that the definitions in the source file actually <strong>match</strong> the declarations in the header file.</p>
</div>
<h2 id="compilinglinking">Compiling &amp; linking</h2>
<p>In our simple example compiling and linking seems to be an easy step.
Unfortunately this is not the case in all but the simplest examples.
The line <code>g++ -o hw main.cpp hello.cpp</code> recompiles <strong>everything</strong>, <strong>always</strong>!
Very quickly this approach will become painfully slow and cumbersome.</p>
<p>To make the compilation process more efficient we need to distinguish between different phases during the translation of source code to a working binary program:</p>
<ul>
<li><strong>Compilation</strong>: translation of a compilation unit (<strong>one</strong> <code>.cpp</code> file with all its included headers; often also called <em>translation unit</em>) to a binary <code>.o</code> (object) file. Consists of, roughly spoken, two things:<ul>
<li><strong>Preprocessing</strong>: handles the preprocessor directives (e.g. <code>#include</code>, <code>#ifndef</code>, <code>#define</code> etc.) to create an intermediate source file with all headers and macros resolved.
  Usually, you don't get to see that file unless you specifically ask for it by passing the <code>-E</code> option to <code>g++</code>.</li>
<li><strong>Code generation</strong>: translates the preprocessed source of the compilation unit into binary code (<code>.o</code> file), which contains the machine code with placeholders for code from other compilation units.
  This means, for example, that the file <code>main.o</code> will <strong>not</strong> contain the machine code of the function <code>hello</code>, but it will know how to call it from the <code>hello.o</code> file through a placeholder that will be resolved during <strong>linking</strong>. (In other words: <strong>declarations get resolved</strong>)</li>
</ul>
</li>
<li><strong>Linking</strong>: "glueing" object files together into one single executable (the placeholders will be resolved and replaced by real code). 
  Resolving any static or shared libraries is also done in this phase. (In other words: <strong>definitions get resolved</strong>)</li>
</ul>
<p>Until now, you've been doing all that in just one command, but it actually makes sense to separate the two phases.<br />
Compilation is done using the <code>-c</code> option in <code>g++</code> (for all compilation units separately!):</p>
<pre class="prettyprint"><code>g++ -c main.cpp
g++ -c hello.cpp
</code></pre>
<p>The resulting object files are linked into a binary called <code>hw</code> with:</p>
<pre class="prettyprint"><code>g++ -o hw main.o hello.o
</code></pre>
<p>The useful effect of splitting up the compilation in these two phases is that during development you only need to recompile the sources that have changed since the last compilation.
On the other hand, linking needs to be re-done for all object files, but since it's a much faster process the speed gains are tremendous anyway.
The only issue that still remains is: how do we know precisely which files need to be recompiled?</p>
<h3>Makefiles</h3>
<p>Since around 1977 a tool called <code>make</code> is widely used to automate the build process on UNIX machines.
The programmer writes a <code>Makefile</code> like this one:</p>
<pre class="prettyprint"><code>CXX = g++
CXXFLAGS = -Wall
LDFLAGS =

all: oef1 oef2

oef1: oef1.o
    $(CXX) $(LDFLAGS) -o $@ $^

oef2: oef2.o
    $(CXX) $(LDFLAGS) -o $@ $^

clean:
    $(RM) oef1.o oef1 oef2.o oef2
</code></pre>
<p>This for instance specifies the C++ compiler to be used (the <code>CXX</code> variable), which compilation flags should be appended (<code>CXXFLAGS</code>) and how the different "targets" should be created or cleaned up.
To build the defult target (<code>all</code>) you just type <code>make</code> on the command line and all is done automatically for you.
If you really want to know more, read some <a href="http://www.gnu.org/software/make/manual/make.html">GNU make documentation</a>.</p>
<p>Although functional, the above example will not track dependencies between source files and header files. 
I.e.: it does <strong>not</strong> know which source files need to be recompiled if some header files are modified.</p>
<h3>CMake</h3>
<p>Fortunately there are alternatives to the old &amp; dusty <code>make</code>; one of which is <a href="http://www.cmake.org/">CMake</a>, "Cross Platform Make".
Various arguments in favor of using CMake are:</p>
<ul>
<li>It's a widely used, modern and well documented.</li>
<li>CMake is cross-platform: works on just about any decent OS; for example:<ul>
<li>On Linux / UNIX CMake will automatically create awesome makefiles with dependency checking and other fancy stuff.
  After generating these, you just call <code>make</code>.</li>
<li>On Windows CMake can generate MSVC project files.</li>
<li>On OS X you can tell it to generate Xcode project files. 
  Since OS X is UNIX-compliant it can generate makefiles as well; this is what I'd suggest you should do.</li>
<li>Other options include Kdevelop, Eclipse project files, CLion's project model is based on CMake, etc.</li>
</ul>
</li>
<li>CMake is pretty good at finding requested libraries on your system, as you'll experience in a later lab session.</li>
<li>It's <strong>much</strong> easier to set up &amp; maintain than writing complicated makefiles.</li>
</ul>
<div class="alert alert-success">
<p>Some good reading material to get you started can be found here: <a href="https://gitlab.kitware.com/cmake/community/wikis/FAQ">CMake FAQ</a>.</p>
</div>
<h4>A working example</h4>
<p>Here's a basic working example of how to set up a small project using CMake to get you started.
You can use &amp; extend it to fit your own purposes.</p>
<p>All project files are contained in a top-level project directory with the
following subdirectories and files:</p>
<ul>
<li><code>build/</code> (<strong>disposable</strong> directory for temporary build files; usually you don't need to browse it that often)</li>
<li><code>CMakeLists.txt</code> (top-level CMake file with project definition)</li>
<li><code>src/</code> (contains sources and other support files)<ul>
<li><code>CMakeLists.txt</code> (build information specific to the sources in this directory)</li>
<li><code>hello.cpp</code></li>
<li><code>hello.h</code></li>
<li><code>main.cpp</code></li>
</ul>
</li>
</ul>
<p><code>CMakeLists.txt</code> looks like:</p>
<pre class="prettyprint"><code>CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
PROJECT(HelloWorld)
SET(CMAKE_CXX_FLAGS "-Wall")
ADD_SUBDIRECTORY(src)
INSTALL(TARGETS hw DESTINATION bin)
IF (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  SET (CMAKE_INSTALL_PREFIX "${CMAKE_BINARY_DIR}/installed" CACHE PATH "default install path" FORCE)
ENDIF()
</code></pre>
<p><code>src/CMakeLists.txt</code> looks like:</p>
<pre class="prettyprint"><code>SET(SRC hello.cpp main.cpp)
ADD_EXECUTABLE(hw ${SRC})
</code></pre>
<p>Now go to the project directory and create the temporary build directory:</p>
<pre class="prettyprint"><code>mkdir build
</code></pre>
<p>Go inside the <code>build</code> directory and call CMake with the path to the directory containing the <strong>top-level</strong> <code>CMakeLists.txt</code> file.
This could be a relative path as in this example:</p>
<pre class="prettyprint"><code>cd build
cmake ..
</code></pre>
<p>Still inside the <code>build</code> directory (Notice the bunch of files generated by CMake, including a <code>Makefile</code>), invoke <code>make</code> to build the <code>hw</code> executable:</p>
<pre class="prettyprint"><code>make
</code></pre>
<p>If the build was successful you can install the <code>hw</code> binary to the predefined install location, <code>installed/bin/</code> in this case, by invoking <code>make</code> with the <code>install</code>
target:</p>
<pre class="prettyprint"><code>make install
</code></pre>
<p>Finally, you can launch the compiled executable by running:</p>
<pre class="prettyprint"><code>./installed/bin/hw
</code></pre>
<p>If you change any of the source files, you just type <code>make install</code> to automatically rebuild and reinstall only what's needed.
By default, CMake will install programs to the <code>/usr/local/</code> directory on Linux, which is meant for manually installed system programs, as opposed to programs installed by the package manager, which usually reside directly in <code>/usr/</code>.
For our simple program, it's not really necessary to install them as a system program, so we set the default <code>CMAKE_INSTALL_PREFIX</code> to our <code>build/installed</code> folder instead using the last 3 lines of our top-level <code>CMakeLists.txt</code>.
If you want to change where the program is installed, you can always change the <code>CMAKE_INSTALL_PREFIX</code> to a different directory by running:</p>
<pre class="prettyprint"><code>cmake -DCMAKE_INSTALL_PREFIX=/tmp/hello_world ..
</code></pre>
<p>Instead of the regular <code>cmake ..</code> command, which after running <code>make install</code> again, will install our executable to <code>/tmp/hello_world/bin/hw</code>.</p>
<p>In case you want to get rid of all the temporary files generated by CMake during the build process, just remove the <code>build</code> directory. 
This keeps your project organized and your sources clean from any useless junk.</p>
<div class="alert alert-success">
<p>You'll see more advanced uses of CMake (finding &amp; linking to libraries, creating your own libraries, etc.) as we progress through the sessions.</p>
</div>
<h2 id="versioncontrol">Version control</h2>
<p>Sooner rather than later you'll be writing hundreds lines of code and more, possibly collaborating with other people.
Keeping track of changes in your code over its development time will become essential. 
<strong>Version</strong> or <strong>revision control software</strong> allows you to do just that: keep a history of what happened to your source files at what time.</p>
<p>Some of the more important reasons to use some kind of revision control software are:</p>
<ul>
<li><strong>Humans make mistakes</strong>: revision control allows you to make backups, revert to previous versions, revise changes made in the past etc.</li>
<li><strong>Straightforward collaboration</strong>: both distributed systems and those based on a central repository allow you to work together with other people while keeping track of who did what and when.</li>
<li><strong>Experimenting</strong>: you can create <em>branches</em> to add experimental features to your code without breaking the production code and work on different versions of the same code base in parallel. These branches can be <em>merged</em> later on.</li>
</ul>
<p>If you're still not convinced, go have a look at <a href="http://en.wikipedia.org/wiki/Revision_control">Wiki: Revision Control</a> and <a href="https://git-scm.com/about">About git</a>.
The most popular version control program is <code>git</code>, which we will also be using in this course for the exercises and project.</p>
<h3>In practice</h3>
<p><span class="label label-success">Important</span> To manage the project and exercises, you need to create an account on <a href="https://education.github.com/students">GitHub</a>! 
You should register via the Education program, so you get access to free private repositories and tons of other advantages (scroll down on the website).
It is part of the course, and you will need a UAntwerp-based account to submit assignments (i.e., use your UAntwerp student email address to register an account). </p>
<p>I won't cover all the intricate details of how to work with git; that's up to you to discover (you can find excellent documentation for them online).
Although I will give you a short walkthrough of the typical workflow involved.</p>
<h4>Your average daily Git session</h4>
<p>Suppose you have a project, just like the one you've used in the CMake walkthrough earlier, sitting in a directory called <code>HelloWorld</code>.
First you need to make sure git knows this directory is a repository.
Go inside the directory and <strong>initialize</strong> the repository:</p>
<pre class="prettyprint"><code>cd HelloWorld/
git init
</code></pre>
<p>This will create a hidden <code>.git</code> directory inside <code>HelloWorld</code> (you can check this with <code>ls -la</code>).
This <code>.git</code> directory will contain the whole repository.
Don't remove it, unless you want to lose the repository information, history etc.</p>
<p>The repository you created is still empty though (regardless of the files inside <code>HelloWorld</code>).
To add the files to version control you type:</p>
<pre class="prettyprint"><code>git add src/
git add CMakeLists.txt
</code></pre>
<p>This will make sure Git tracks all files inside the <code>src/</code> subdirectory of <code>HelloWorld</code> and the top-level <code>CMakeLists.txt</code> file. 
The reason for the explicit specification of which files to track is to prevent trashing your repository with temporary binary files and other build artifacts that are not worth saving and can be regenerated automatically anyway.</p>
<p>To check what's <strong>staged</strong> for the upcoming <strong>commit</strong>, issue: <code>git status</code>.
Mine gives:</p>
<pre class="prettyprint"><code># On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file&gt;..." to unstage)
#
#   new file:   CMakeLists.txt
#   new file:   src/CMakeLists.txt
#   new file:   src/hello.cpp
#   new file:   src/hello.h
#   new file:   src/main.cpp
#
</code></pre>
<p>Nice!</p>
<p>To permanently save the current state of the files listed above in your repository you need to <strong>commit</strong> your changes. Just do:</p>
<pre class="prettyprint"><code>git commit -m "Initial commit of the HelloWorld project"
</code></pre>
<p>which should give something similar to</p>
<pre class="prettyprint"><code>[master (root-commit) 2aecdc2] Initial commit of the HelloWorld project
 5 files changed, 46 insertions(+)
 create mode 100644 CMakeLists.txt
 create mode 100644 src/CMakeLists.txt
 create mode 100644 src/hello.cpp
 create mode 100644 src/hello.h
 create mode 100644 src/main.cpp
</code></pre>
<p>At this point you've permanently "recorded" the state of your repository.  You can check this with <code>git log</code>.
Also, <code>git status</code> will now claim that your working copy is <em>clean</em>; all changes have been committed, and the current files reflect the most recent state of the repository.</p>
<p>Now let's make some random changes to the <code>hello.cpp</code> file, save it and check the state of the repository again with <code>git status</code>:</p>
<pre class="prettyprint"><code># On branch master
# Changes not staged for commit:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
#
#   modified:   src/hello.cpp
#
no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>
<p>Git knows that you've changed hello.cpp with respect to its most recent state in the repository. 
You can check what the differences are with <code>git diff</code>:</p>
<pre class="prettyprint"><code>diff --git a/src/hello.cpp b/src/hello.cpp
index 8e37833..68be36c 100644
--- a/src/hello.cpp
+++ b/src/hello.cpp
@@ -3,6 +3,6 @@
 using namespace std;

 void hello() {
-    cout &lt;&lt; "Hello world!" &lt;&lt; endl;
+    cout &lt;&lt; "Almost time for a short break!" &lt;&lt; endl;
 }
</code></pre>
<p>If you're happy with this you can commit it. 
You first <code>add</code> files to be committed (i.e. put them in the <em>stage</em> area) and then commit those added files. 
You can also use the <code>-a</code> flag to commit all the files, but this is considered bad practice as your individual commits get too messy (i.e., when you want to <code>revert</code> back to a certain commit, it can contain a lot of changes that you do not want) and the commit messages will get too long.
It is important to exactly describe (but keep it short) which feature you added to your code base so future you (or colleagues) know(s) exactly what your commit contains:</p>
<pre class="prettyprint"><code>git commit -am "Changed the output message."
</code></pre>
<p>which reassures me all is fine with this message:</p>
<pre class="prettyprint"><code>[master ab94d0d] Changed the output message.
 1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p><code>git log</code> will now show two commits in history.</p>
<h4>Summary</h4>
<p>You've used a bunch of the most common Git commands.
There are some more that are useful in a usual workflow.
For example when working with a <strong>remote repository</strong> like GitHub. 
Here's a short summary of the commands you'll be using most frequently:</p>
<table class="table table-hover table-condensed">
<thead>
<tr>
<th>Git commands</th>
<th />
</tr>
</thead>
<tbody>
<tr>
<td><code>init</code></td>
<td>Initializes a new repository</td>
</tr>
<tr>
<td><code>add</code></td>
<td>Adds / stages files for the upcoming commit</td>
</tr>
<tr>
<td><code>commit</code></td>
<td>Commits (saves) staged changes to the repository (or <strong>all</strong> changes, if you use the <code>-a</code> flag)</td>
</tr>
<tr>
<td><code>log</code></td>
<td>Lists all commits in chronological order</td>
</tr>
<tr>
<td><code>status</code></td>
<td>Shows the state of the working copy w.r.t. the repository</td>
</tr>
<tr>
<td><code>clone</code></td>
<td>Makes a clone of a repository for local use. This is the most common way of getting access to someone else's repository</td>
</tr>
<tr>
<td><code>push</code></td>
<td>If you're working with a remote repository (like a repository on GitHub for instance) this will sync the remote repository with the commits you've made locally</td>
</tr>
<tr>
<td><code>pull</code></td>
<td>Just like <code>push</code> but the other way around: syncs your repository with the remote</td>
</tr>
</tbody>
</table>
<p>Most of these commands have a wide variety of possible options and parameters.
Consult the online documentation or the Git manual (<code>man git</code>) for more information.</p>
<h2 id="codingconventions">Coding conventions</h2>
<p><span class="label label-success">Important</span>
Make sure you write code that you'll understand 6 months from now: code for <strong>readability</strong> and <strong>consistency</strong>! 
In order to do so try to follow the coding conventions from the course notes.</p>
<h3>Code formatting</h3>
<p>Code formatting is a first step towards readable code. A well-known command line code formatter is <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a>.
An example usage is:</p>
<pre class="prettyprint"><code>clang-format -i -style=file main.cpp
</code></pre>
<p>The <code>-style=file</code> option tells <code>clang-format</code> to search for <code>.clang-format</code> file in the current directory from which it will read the formatting rules.
The <code>-i</code> tells <code>clang-format</code> to immediately apply the changes.
If you drop this option, <code>clang-format</code> only shows you the proposed changes.</p>
<p>An advantage of this command line tool is that you can auto-format your code every time you commit/push it to your Git repository, by using so-called Git hooks: look <a href="http://kaskavalci.com/using-git-hooks-to-format-your-code/">here</a>.
This way you only have nicely formatted code in your code repository!</p>
<div class="alert alert-success">
<p>In this course all code needs to be formatted using the <code>.clang-format</code> <a href="https://github.com/Advanced-Programming-UA/Object-Tracer/blob/main/.clang-format">file of the Object Tracer</a>.
So the use of <code>clang-format</code> is needed.</p>
</div>
<p /><center>
<img alt="Tabs vs. Spaces" src="http://www.emacswiki.org/pics/static/TabsSpacesBoth.png" class="img-responsive" />
</center><p />
<h3>Documentation</h3>
<p>Writing comments in your code is <strong>essential</strong>. It will make <strong>you</strong> happy during code maintenance and <strong>other's</strong> lives easier if they ever need to read or use your code.</p>
<p>Usually, programmers tend to avoid writing comments until the moment they have to deliver their project. Avoid this and learn to comment your code as you write it.
This will save you a lot of time later in the project (it is not fun having to focus on writing documentation when a deadline is approaching) and it helps you to understand your code when you are extending it.</p>
<p>There's a well-known tool, <a href="http://www.doxygen.nl/">Doxygen</a>, that can auto-generate documentation from your C++ code and the comments you write.
We strongly advise you to write special Doxygen comment blocks, especially in your project.
To use Doxygen, first step is to go inside your source directory and generate a Doxygen config file:</p>
<pre class="prettyprint"><code>doxygen -g &lt;config_file&gt;
</code></pre>
<p>You can edit the generated config file as much as you want. Then run:</p>
<pre class="prettyprint"><code>doxygen &lt;config_file&gt;
</code></pre>
<p>to run Doxygen based on the config file.
You will see (at least) a <strong>html</strong> directory appear which contains your generated documentation.</p>
<p>Take a look at
some Doxygen-generated documentation examples <a href="http://www.doxygen.nl/results.html">here</a>.</p>
<h3>Code inspection</h3>
<p>Next to formatting and documenting code, nicely written source code should also avoid typical programming errors, issues, style violations, ... 
While a lot of them will not result in compile errors, they can be considered bad practice, can give surprising run-time effects and as such should be avoided.
Luckily, there is also a tool for that: <code>clang-tidy</code>, part of the LLVM framework.
It is an extensible framework for diagnosing such typical programming issues.</p>
<p><code>clang-tidy</code> supports <strong>Clang Static Analyzer checks</strong> which is a code analysis tool (also part of LLVM) to find bugs in C++ (or C) programs and which can also be used as <a href="https://clang-analyzer.llvm.org/">standalone tool</a>. Next to those checks, it also supports <strong>a group of other checks</strong> (e.g., checks related to Boost, Android, etc.) that can be individually enabled. Check <a href="http://clang.llvm.org/extra/clang-tidy/#using-clang-tidy">the website</a> for more information.</p>
<p>The CLion IDE has a similar <a href="https://www.jetbrains.com/help/clion/code-inspection.html">code inspection</a> built-in in its interface: <strong>Code &gt; Inspect Code</strong>.
It detects the language and runtime errors, suggests corrections and improvements.
You can see all the possible checks it does in <strong>Preferences &gt; Editor &gt; Inspections</strong>.
As you can see there, also <code>clang-tidy</code> is included, meaning that when running the code inspection provided by CLion, you also run the <code>clang-tidy</code>!</p>
<p>Check these pages for more information:</p>
<ul>
<li><a href="http://clang.llvm.org/extra/clang-tidy/">clang-tidy</a></li>
<li><a href="https://clang-analyzer.llvm.org/">Clang Static Analyzer</a></li>
<li><a href="https://www.jetbrains.com/help/clion/code-inspection.html">CLion's Code Inspection</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<p>"Let's see what you remember from last year"</p>
<p>You will only be able to accept an assignment with your UAntwerpen-based GitHub account.
Once you've accepted an assignment, it will be added to your account as a private repository to which you will also have to commit the solution of the assignment.
The deadline of an exercise will typically be two days before the next lab session, but for this first session you get an extra week, so you'll have the opportunity to ask questions in person.
You are expected to submit these exercises, but they will not count towards your grade for this course.
They are meant to make sure that you digest the material for each session in a timely manner, because near the end of the semester you will be too busy with the project and practising for the tracing exam to also study all the lab sessions right before the exam.</p>
<h3>Fix My Code</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/6FotSUAa">https://classroom.github.com/a/6FotSUAa</a></p>
<!-- This thing doesn't work. Find out why and fix it!

    /**
     * TODO: fix me! I was really in a hurry this morning...
     */
    #include <iostream>
    #include <vector>

    /**
     * Prints a vector of integers to cout
     */
    void printVec(vector<int> v) {
        for (int i = 0; i < v.length(); ++i) {
            cout << "v[" << i << "] = "  << v[i] << endl;
        }
    }

    /**
     * Returns the sorted version of the provided vector of integers.
     * Sorting is done by means of the almighty bubble sort algorithm.
     */
    vector<int> bubbleSort(vector<int> v) {
        bool sorted = false;
        while (!sorted) {
            sorted = true;
            for (int i == 0; i < v.length(); ++i) {
                if (v[i] > v[i+1]) {
                    swap(v[i], v[i+1]);
                    sorted = false;
                }
            }
        }
        return v;
    }

    int main(int argc, char* argv[]) {
        // Define the vector to be sorted
        vector<int> w;
        w.push_back(2);
        w.push_back(4);
        w.push_back(1);
        w.push_back(7);
        w.push_back(5);

        // Check how it looks like
        cout << "unsorted:" << endl;
        printVec(w);

        // Get a sorted version of w
        sorted_w = bubbleSort(w);

        // Check if it's really sorted
        cout << "sorted:" << endl;
        printVec(sorted_w);

        return 0;
    } -->

<h3>ASCII Table</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/1HirypoQ">https://classroom.github.com/a/1HirypoQ</a></p>
<!-- Write a program that prints out the whole ASCII table to the terminal. Use
proper conversion from `int` to `char`. -->

<h3>Factorials</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/icz_z__W">https://classroom.github.com/a/icz_z__W</a></p>
<!-- Write one **recursive** and one **iterative** factorial function (use `unsigned
long int`). You obviously know that `n! = n * (n-1) * (n-2) * .. * 1` for `n >
0` and that `0! = 1`.

Test it with an interactive program that asks the user for an integer. Proceed
only if the provided input is positive.

Watch out, at some point the result will not fit in an `unsigned long int`. Try it out
-->

<!--If
you want to know more, read [INT30-C. Ensure that unsigned integer operations
do not
wrap](https://www.securecoding.cert.org/confluence/display/c/INT30-C.+Ensure+that+unsigned+integer+operations+do+not+wrap).
(Warning: you might lose all your faith in computers if you read more about
secure coding practices and how they are ignored in a vast majority of written
software!))-->

<h3>Fibonacci</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/nVhqlI3K">https://classroom.github.com/a/nVhqlI3K</a></p>
<!-- Write a program that reads a number `n` (using `std::cin`) and prints all
Fibonacci numbers `F_0` to `F_n`. You obviously know that `F_n = F_{n-2} +
F_{n-1}` with `F_0 = F_1 = 1`. -->

<!-- ### Git Version Control

Create online a new Git repository called *fibonacci*, using your Bitbucket account. Set up the same git repository locally following the Bitbucket instructions titled *I'm starting from scratch*. These will instruct you to set up a repository from a directory that is not yet a git repository.

When your repository is set up locally, push your Fibonacci code to your *remote* (a.k.a. online) repository.

For the following part, you will need to read up on branching: start  [here](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging). When your Fibonacci code is safely pushed to your remote repository, make a new git `branch` called *not_fibonacci*. Switch to this branch. Adjust your Fibonacci code so it implements this formula `F_n = F_{n-3} + F_{n-2} + F_{n-1}` with `F_0 = F_1 = F_2 = 1`. When finished, push your Finoacci code to your remote branch and switch back to your `master` branch. --></div></body></html>
					</div>
				</div>
			</div>

			<div class="footer">
				<p class="text-muted">&copy; <a href="mailto:thomas.ave@uantwerpen.be">Thomas Avé</a> / IDLab / Universiteit Antwerpen.</p>
			</div>
		</div>

		<script src="https://code.jquery.com/jquery.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/google-code-prettify/prettify.js"></script>
	</body>
</html>
