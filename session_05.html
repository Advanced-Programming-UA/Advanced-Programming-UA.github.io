<!DOCTYPE html>
<html lang="en">
	<head>
		<title>C++ lab sessions</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<style type="text/css">
			body {
				padding-top: 70px;
			}
			.footer {
				border-top: 1px solid #eee;
				margin-top: 20px;
				padding-top: 20px;
				padding-bottom: 10px;
			}
			h2 {
				padding-top: 60px;
			}
		</style>
		<!-- Google prettify -->
		<link href="js/google-code-prettify/my-prettify.css" rel="stylesheet">
		<!--<link href="http://twitter.github.io/bootstrap/assets/js/google-code-prettify/prettify.css" rel="stylesheet">-->
	</head>
	<body onLoad="prettyPrint()" data-spy="scroll" data-target="#subnavigation">
		<div class="container">
			<div class="navbar navbar-default navbar-fixed-top hidden-print">
				<div class="container">
					<div class="navbar-header">
						<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
							<span class="icon-bar"></span>
						</button>
					</div>
					<div class="navbar-collapse collapse">
						<ul class="nav navbar-nav">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									C++ lab sessions
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<li><a tabindex="-1" href="index.html">Overview</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="session_00.html">Session 0 (06/10/2022)</a></li>
<li><a tabindex="-1" href="session_01.html">Session 1 (13/10/2022)</a></li>
<li><a tabindex="-1" href="session_02.html">Session 2 (20/10/2022)</a></li>
<li><a tabindex="-1" href="session_03.html">Session 3 (03/11/2022)</a></li>
<li><a tabindex="-1" href="session_04.html">Session 4 (09/11/2022)</a></li>
<li class="active"><a tabindex="-1" href="session_05.html">Session 5 (17/11/2022)</a></li>
<li><a tabindex="-1" href="session_06.html">Session 6 (24/11/2022)</a></li>
<li><a tabindex="-1" href="session_07.html">Session 7 (01/12/2022)</a></li>

								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">
									Quick links
									<span class="caret"></span>
								</a>
								<ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
									<!-- Hard coded links to useful sites, open in new tab -->
									<li><a tabindex="-1" href="http://www.cplusplus.com/" target="_blank">cplusplus.com</a></li>
									<li><a tabindex="-1" href="http://en.cppreference.com/" target="_blank">cppreference.com</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://www.cmake.org/Wiki/CMake_FAQ" target="_blank">CMake documentation</a></li>
									<li class="divider"></li>
									<li><a tabindex="-1" href="http://git-scm.com/book" target="_blank">Git documentation</a></li>
								</ul>
							</li>
						</ul>
					</div>
				</div>
			</div>

			<div class="container">
				<div class="row">
					<!-- Subnav bar is only visible on large devices -->
					<div id="subnavigation" class="col-lg-3 col-md-3 visible-md visible-lg hidden-print">
						<ul class="nav nav-pills nav-stacked" style="position: fixed">
							<h3>Jump to:</h3>
							<li><a tabindex="-1" href="#summary">Summary</a></li>
<li><a tabindex="-1" href="#testyourinheritanceskills">Test your inheritance skills</a></li>
<li><a tabindex="-1" href="#exceptionhandling">Exception handling</a></li>
<li><a tabindex="-1" href="#operatoroverloadingbis">Operator overloading (bis)</a></li>
<li><a tabindex="-1" href="#smartpointers">Smart pointers</a></li>
<li><a tabindex="-1" href="#exercises">Exercises</a></li>

						</ul>
					</div>
					<div class="col-lg-9 col-md-9">
						<html><head /><body><div><div class="page-header"><h1>Session 5 (17/11/2022)</h1></div>
<h2 id="summary">Summary</h2>
<p>We will first start off with a small test to check your inheritance skills after session 3.
Afterwards, two subjects related to "safe programming" are the main topic of today's lab session: error handling through the use of <strong>exceptions</strong> and <code>std</code> features related to managing memory: <strong>smart pointers</strong>.
We'll also cover a small addition to operator overloading: user-defined <strong>typecast operators</strong>.</p>
<h2 id="testyourinheritanceskills">Test your inheritance skills</h2>
<p>Look at following source code files. Try to figure out what is going on and what will be printed. Check your answer by running the actual code.</p>
<p>Test 1:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

class Base {
public:
    void print() { std::cout &lt;&lt; "Base!" &lt;&lt; std::endl; }
};


class Derived : public Base {
public:
    void print() { std::cout &lt;&lt; "Derived!" &lt;&lt; std::endl; }
};

int main()
{
    Base b;
    Derived d;
    b = d;
    b.print();

    Base* b2 = new Derived();
    b2-&gt;print();
}
</code></pre>
<p>Test 2:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

class Base {
public:
    Base() { std::cout &lt;&lt; "Base constructor!" &lt;&lt; std::endl; }
    Base(int b) : x(b) { std::cout &lt;&lt; "One argument Base constructor!" &lt;&lt; std::endl; }
    virtual void print() { std::cout &lt;&lt; "Base!" &lt;&lt; std::endl; }
private:
    int x;
};


class Derived : public Base {
public:
    Derived() { std::cout &lt;&lt; "Derived constructor!" &lt;&lt; std::endl; }
    Derived(int d) : x(d) { std::cout &lt;&lt; "One argument Derived constructor!" &lt;&lt; std::endl; }
    virtual void print() { std::cout &lt;&lt; "Derived!" &lt;&lt; std::endl; }
private:
    int x;
};

int main()
{
    Base* b2 = new Derived(5);
    b2-&gt;print();
}
</code></pre>
<p>Test 3:</p>
<pre class="prettyprint"><code>#include &lt;iostream&gt;

class Base {
public:
    Base() { std::cout &lt;&lt; "Base constructor!" &lt;&lt; std::endl; }
    virtual ~Base() { std::cout &lt;&lt; "Base destructor!" &lt;&lt; std::endl; }
};


class Derived : public Base {
public:
    Derived() { std::cout &lt;&lt; "Derived constructor!" &lt;&lt; std::endl; }
    ~Derived() { std::cout &lt;&lt; "Derived destructor!" &lt;&lt; std::endl; }
};

int main()
{
    Base* b = new Derived();
    delete b;

    Derived d2;
    Base b2(d2);
}
</code></pre>
<p>Be sure that you really understand what is going with each test. If you have questions concerning the output, do not hesitate to ask!</p>
<h2 id="exceptionhandling">Exception handling</h2>
<p><span class="label label-success">Important</span> C++ has a well-structured mechanism to report and handle errors and unforeseen events: <strong>exceptions</strong>.
(<em>unforeseen</em> or <em>exceptional</em> in this context means: "some part of the system couldn't do what it was asked to do") </p>
<p>An <strong>exception</strong> is an <strong>object</strong> of some class representing an exceptional event.
It might (and often does) contain additional information about the cause of the event; for instance a string containing a more detailed error message.
Since exceptions are instances of classes, they can be grouped in hierarchies of exceptions.
This allows for a hierarchical error handling: <strong>specific errors</strong> (think: <strong>derived classes</strong>) can be handled closer to where the error occurred; for instance deep in the internals of some library.</p>
<p>More <strong>general errors</strong> (think: <strong>base classes</strong>) can be handled higher up in the hierarchy; for instance in client code that uses the library.</p>
<h3>Basic usage</h3>
<p>The code that could <strong>throw</strong> an exception is wrapped in a <code>try</code> block.
Whenever an exception is thrown, the program's control flow immediately jumps to the <code>catch</code> blocks that directly follow the <code>try</code> block.
The <code>catch</code> blocks are considered in order; the one that <strong>first matches</strong> the thrown exception's type is executed.
After handling the exception in the <code>catch</code> block, the program resumes "normal" execution right after the catch blocks.</p>
<p>Play around with the example below to see how it works:</p>
<pre class="prettyprint"><code>try {
    // Code that might throw an exception, for example:
    throw MyException();
} catch (MyException&amp; e) {
    // Handle a 'MyException'
    cout &lt;&lt; "MyException: don't worry, be happy!" &lt;&lt; endl;
} catch (YourException&amp; e) {
    // Handle a 'YourException'
    cout &lt;&lt; "YourException: this really is the end of it all!" &lt;&lt; endl;
} catch (...) {
    // catch-all: handle every other exception that did not match
    // any of the above catch clauses
    cout &lt;&lt; "Something happened but I don't know what..." &lt;&lt; endl;
}

cout &lt;&lt; "Just kidding, carry on!" &lt;&lt; endl;
</code></pre>
<div class="alert alert-success">
<p>The semantics of catching an exception is the same as a function accepting an argument: <strong>initialization</strong>. 
If you want to <strong>prevent slicing</strong>, you'll have to catch exceptions <strong>by pointer</strong> or <strong>by reference</strong>, as is done in the example above.
You can also use <code>const</code> to prevent accidental changes to exceptions in handlers.</p>
</div>
<h3>Nesting</h3>
<p>Obviously <code>try</code>-<code>catch</code> blocks can be nested; for example:</p>
<pre class="prettyprint"><code>try {
    // stuff to try
    try {
        // other stuff to try
    } catch (std::exception &amp;e) {
        // solve problem
    } catch (...) {
        // solve another problem
    }
} catch (...) {
    // whatever
}
</code></pre>
<p>Watch out you don't end up reproducing <code>if</code>-<code>then</code>-<code>else</code> blocks with a mess of nested or linear exception handlers: read <a href="https://isocpp.org/wiki/faq/exceptions#too-many-trycatch-blocks">C++FAQ on exceptions</a>.</p>
<h3>Rethrow</h3>
<p>A previously thrown exception can be re-thrown for further error handling:</p>
<pre class="prettyprint"><code>try {
    // whatever
} catch (std::exception &amp;e) {
    // handle the error partially
    throw;
}
</code></pre>
<p>Note that the <strong>original</strong> exception is re-thrown! (I.e.: no slicing etc...)</p>
<h3>Constructors &amp; destructors</h3>
<p>As you might have guessed, special care needs to be taken when exceptions are used during an object's construction and destruction.
When an exception is thrown in a constructor, the object is <strong>not fully constructed</strong>.
The destructor (that might otherwise free the previously allocated resources) of the "half-baked" object will not be called, which leaves the object in a potentially half-initialized state with dangling resources.
A good rule of thumb is that <strong>every member object must manage its own destruction</strong>.
This is discussed in the C++ FAQ's section on <a href="https://isocpp.org/wiki/faq/exceptions#selfcleaning-members">selfcleaning members</a>.</p>
<p>I highly recommend you to read cppreference's <a href="http://en.cppreference.com/w/cpp/language/raii">RAII: Resource Acquisition Is Initialization</a> programming idiom now.
This idiom also goes by the more intuitive name "Scope-Bound Resource Management".</p>
<p>Constructors (don't forget the copy constructor!) allow a way of enclosing their initializer lists in a <code>try</code> block as well.
Consider this hypothetical example:</p>
<p><code>Sprite.h</code>:</p>
<pre class="prettyprint"><code>/**
    The Sprite class represents an image that can be drawn on the screen.
*/
class Sprite {
    public:
        Sprite(std::string file_name);
        ~Sprite();
        void setImage(Image img);
        void draw(Surface s, Coord2d xy);

    private:
        Image m_img;
};
</code></pre>
<p><code>Sprite.cpp</code>:</p>
<pre class="prettyprint"><code>#include "Sprite.h"

Sprite::Sprite(std::string file_name)
try : m_img(file_name) {
      // constructor
} catch (exception&amp; e) {
    cout &lt;&lt; "Error loading sprite image: " &lt;&lt; e.what() &lt;&lt; &lt;&lt; endl;
}

Sprite::~Sprite() {
    // We don't need to clean up anything. Image's destructor will releaase
    // its own resources. Cfr.: RAII.
}

void Sprite::setImage(Image img) {
    m_img = img;
}

void Sprite::draw(Surface s, Coord2d xy) {
    // Draw sprite's image on the surface s at position xy
    ...
}
</code></pre>
<p>Whenever a <code>Sprite</code> is being constructed requesting an image file that cannot be accessed for whatever reason, <code>Images</code>'s constructor throws an exception that will be caught by <code>Sprite</code>'s constructor.
The situation can be resolved later by loading the proper image manually with <code>Sprite::setImage</code>.</p>
<p>As a general rule, <strong>destructors must not throw exceptions!</strong>. 
More specifically, if a destructor throws an exception, <strong>it must be handled internally within the destructor</strong>.
It may not leave the destructor's body! 
See: <a href="https://isocpp.org/wiki/faq/exceptions#dtors-shouldnt-throw">C++ FAQ 17.9</a>.</p>
<p>Of course, you can try this just for fun:</p>
<pre class="prettyprint"><code>class A {
    public:
        ~A() {
            throw 1;
        }
};

int main() {
    try {
        A a;
        throw 1;
    } catch (...) {
        cout &lt;&lt; "Will you print me, dear C++?" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<p>Notice I'm throwing an <code>int</code> variable, which is perfectly fine in C++.
You can throw whatever you want, as long as it can be copied.
This doesn't mean that you should do this though.
Generally it is considered best-practise to only throw exceptions that are derived from std::exception.</p>
<h4>Remarks</h4>
<p>Except in very special cases (have a look at the <a href="https://isocpp.org/wiki/faq/exceptions#selfcleaning-members">last paragraph of in this C++ FAQ thread</a>) the memory allocated by the <code>new</code> operator <strong>will be freed properly</strong> when the constructor of the class whose object is being allocated throws an exception.
For example, in cases like:</p>
<pre class="prettyprint"><code>Foo* f = new Foo;
</code></pre>
<p>or</p>
<pre class="prettyprint"><code>Foo* f = new Foo[10];
</code></pre>
<div class="alert alert-success">
<p>The correct use of exceptions is a difficult subject and attracts a lot of extreme opinions.
Read <a href="http://www.codeproject.com/Articles/38449/C-Exceptions-Pros-and-Cons">some</a> <a href="http://www.stroustrup.com/except.pdf">articles</a> to broaden your perspective.
People even dedicate whole <a href="http://exceptionsafecode.com/">lectures</a> to exception safe coding in C++.
Have a look; you'll probably learn something new.</p>
</div>
<h3>Standard library</h3>
<p>The C++'s standard library has a wide variety of different exceptions to handle all the possible error scenarios.
See <a href="http://www.cplusplus.com/reference/exception/exception/">here for an overview</a>.
Notice that all exceptions in the standard library are derived from the <code>std::exception</code> base class (<code>#include &lt;exception&gt;</code> to make it work).</p>
<p>The <code>std::exception</code> class has a (virtual) <code>what()</code> method to retrieve a string with more information about the error.
In the case of the base class this error message is an empty string.
More specific error messages are provided by subclasses of <code>std::exception</code>.
Try this:</p>
<pre class="prettyprint"><code>try {
    vector&lt;int&gt; v = {2, 3, 5, 7};
    v.at(4) = 11;
} catch (exception&amp; e) {
    cout &lt;&lt; e.what() &lt;&lt; endl;
}
</code></pre>
<div class="alert alert-success">
<p>Notice <code>v.at(4)</code> is used instead of the more familiar <code>v[4]</code>.
The difference is that <code>at()</code> does <strong>range checking</strong> and throws an <code>std::out_of_range</code> exception if you're trying to access elements outside the container's range.
On the other hand, <code>[]</code> does no range checking whatsoever and possibly results in a less gracious "Segmentation fault" in the above example.</p>
</div>
<p>Of course, you can derive your own exceptions using <code>std::exception</code> as a base class. 
If you just want a simple exception class with a string as a "reason" and no custom hierarchy of errors you can use <code>std::runtime_error</code> (You'll need to <code>#include &lt;stdexcept&gt;</code>).
It's really very convenient!</p>
<pre class="prettyprint"><code>try {
    ...
    throw runtime_error("Computer says NO!");
    ...
} catch (runtime_error&amp; e) {
    cout &lt;&lt; "An error occurred: " &lt;&lt; e.what() &lt;&lt; endl;
}
</code></pre>
<p>Look at <a href="http://www.cplusplus.com/reference/exception/exception/">cppreference.com</a> for a short explanation about which exception fits which situation: save yourself some work and check this list first before implementing your own exception class! 
Beware that deriving directly from <code>std::exception</code> is perfectly fine, but has the disadvantage that you do not have a constructor that accepts a <code>std::string</code> which is returned by the <code>what()</code> call.
Plus, you should also check the list to see if there is a more specific exception from which you should derive.</p>
<h2 id="operatoroverloadingbis">Operator overloading (bis)</h2>
<p>There's a useful set of operators that we haven't covered yet which can be overloaded as well: the <strong>type-cast operators</strong>.
Recall the <code>Integer</code> wrapper exercise / example from <a href="session_02.html">session 2</a>.  There is, for instance, no way of doing:</p>
<pre class="prettyprint"><code>Integer a = 4;
int b = a;
</code></pre>
<p>You'll get:</p>
<pre class="prettyprint"><code>error: cannot convert 'Integer' to 'int' in initialization
</code></pre>
<p>To make the above statement possible you need to <strong>overload the type-cast operator</strong> <code>Integer::operator int()</code>.
The proper way of doing this is:</p>
<p><code>Integer.h</code>:</p>
<pre class="prettyprint"><code>class Integer {
    ...
    operator int() const;
    ...
};
</code></pre>
<p><code>Integer.cpp</code>:</p>
<pre class="prettyprint"><code>Integer::operator int() const {
    return this-&gt;m_val;
}
</code></pre>
<h2 id="smartpointers">Smart pointers</h2>
<p>Due to a <a href="http://stackoverflow.com/questions/147130/why-doesnt-c-have-a-garbage-collector">variety of reasons</a> C++ requires the programmer to handle memory allocations and deallocations manually.
This has possible advantages for the very experienced programmer, since it allows you to control memory explicitly in order to squeeze the most performance from the code.
<strong>Most commonly though</strong>, the disadvantage is that you can easily introduce bugs, memory leaks, crashes etc.
Fortunately, some level of <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collection</a> is provided by the standard library in <span class="label label-danger">C++11</span> through a form of "reference counting" to ease the pain of manual memory management.
These features are implemented as wrappers around regular pointers and are collectively called <strong>smart pointers</strong>.</p>
<p><em>Raw pointers</em> also have some additional drawbacks, making it hard (but not impossible!) to work with them:</p>
<ul>
<li>Its declaration does not reveal that it points to a single object or to an array</li>
<li>If you do not know if it is a single object or an array, how do you know how to delete it (<code>delete</code> or <code>delete[]</code>)?</li>
<li>Its declaration does not tell you if you should destroy the pointer, i.e., if the pointer <em>owns</em> the thing it points to.</li>
<li>It is difficult to be sure that you only destroy the pointer once in every execution path of your code (and nobody knows what will happen next if you delete a pointer more than once, i.e., undefined behavior).</li>
<li>Suppose that the object to which the pointer you are using points is actually already destroyed (i.e., it is a <strong>dangling</strong> pointer), how do you know?</li>
</ul>
<p>This being said, raw pointers are not <em>wrong</em>. As long as you use them correctly.
Smart pointers can be used by including the <code>&lt;memory&gt;</code> header:</p>
<pre class="prettyprint"><code>#include &lt;memory&gt;
</code></pre>
<p>See also:</p>
<ul>
<li><a href="http://umich.edu/~eecs381/handouts/C++11_smart_ptrs.pdf">University of Michigan's handouts</a> on smart pointers</li>
</ul>
<h3><code>shared_ptr&lt;T&gt;</code></h3>
<p>A <code>shared_ptr&lt;T&gt;</code> implements the concept of <strong>shared ownership</strong>.
A <code>shared_ptr&lt;T&gt;</code> - the <em>manager object</em> - wraps a pointer to an object of type <code>T</code> - the <em>managed or referenced object</em> - while keeping track of how many shared pointers are referring to the same object.
If a copy of the <code>shared_ptr&lt;T&gt;</code> is made, its <strong>reference count is increased</strong> (the reference count is also referred to as the <em>use count</em>), i.e. there's one more pointer that
refers to the same object.
So, a <code>shared_ptr&lt;T&gt;</code> can actually share ownership of a managed object among several <code>shared_ptr&lt;T&gt;</code> objects.</p>
<p>If, on the other hand, the <code>shared_ptr&lt;T&gt;</code> goes out of scope (or is reset explicitly by <code>reset()</code> or the <code>shared_ptr&lt;T&gt;</code> is set to <code>nullptr</code>), the <strong>reference count is decreased</strong>. 
If the reference count becomes 0, there's no more <code>shared_ptr&lt;T&gt;</code> objects referring the original piece in memory and the object pointed to - the managed object - is destructed.</p>
<p><code>shared_ptr&lt;T&gt;</code> in action:</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Foo&gt; sp1(new Foo);            // make a new shared_ptr, reference count is now at 1
std::cout &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    // check the reference count
std::shared_ptr&lt;Foo&gt; sp2 = sp1;               // copy constructor, reference count increases again by 1
std::cout &lt;&lt; sp1.use_count() &lt;&lt; std::endl;    // check the reference count
sp2-&gt;printFoo();                              // you can call a member function like a built-in pointer

std::cout &lt;&lt; *sp1 &lt;&lt; std::endl;               // you can dereference it a like a built-in pointer

std::cout &lt;&lt; &amp;(*sp1) &lt;&lt; std::endl;            // ask for its address
std::cout &lt;&lt; &amp;(*sp2) &lt;&lt; std::endl;            // ask for its address
// the addresses should match up

std::shared_ptr&lt;Foo&gt; sp3 = sp2;
sp2 = nullptr;                                // decreases the reference count
std::cout &lt;&lt; sp3.use_count() &lt;&lt; std::endl;    // check the reference count
sp1.reset();                                  // decreases the reference count
std::cout &lt;&lt; sp3.use_count() &lt;&lt; std::endl;    // check the reference count
</code></pre>
<p>Another nice thing about <code>shared_ptr&lt;T&gt;</code>s (and <code>unique&lt;T&gt;</code>s, but you'll learn about those in one of the next sections) is that you can pass <strong>custom deleters</strong> to them.
When you define a custom deleter and pass them to the <code>shared_ptr&lt;T&gt;</code> object, the moment its reference counts reaches 0 and the referenced object needs to be destroyed, not the common <code>delete</code> will be executed, but your custom defined deleter.</p>
<pre class="prettyprint"><code>auto loggingDeleter = [](Foo* f) { // remember lambda's?
  std::cout &lt;&lt; "Deleting a Foo object..." &lt;&lt; std::endl;
  // you can simply print something here, call a log function, etc.

  delete f;
};

std::shared_ptr&lt;Foo&gt; fooInstance(new Foo, loggingDeleter);
</code></pre>
<p>You do not have to stick to lambda's, you can pass all kind of callable things: normal functions, functors, ... Look it up and try it!</p>
<p>Note that, thanks to operator overloading, shared pointers behave very much like regular pointers; this includes polymorphism etc.</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Base&gt; b_ptr(new Derived(/* ctor arguments */));
b_ptr-&gt;someVirtualMethod();
</code></pre>
<p>Instead of initializing <code>b_ptr</code> using a manually allocated object with the <code>new</code> operator you can use the <code>make_shared</code> function which allocates an object and calls the object's constructor:</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Base&gt; b_ptr = std::make_shared&lt;Derived&gt;(/* ctor arguments */);      
// NOTE: You can actually just pass the Derived constructor arguments to make_shared()!
b_ptr-&gt;someVirtualMethod();
</code></pre>
<p>It is actually preferred to use <code>make_shared&lt;T&gt;</code> instead of <code>shared_ptr&lt;T&gt;(new T)</code>.
One of the reasons is performance: <code>shared_ptr&lt;T&gt;(new T)</code> actually entails two memory allocations (one for the so-called control block - in which all management information is stored - and one for the managed object, i.e., the <code>new</code> allocation), while <code>make_shared&lt;T&gt;()</code> only allocates one memory chunk (and thus only does one memory allocations) which reduces the static program size and increase the speed of the executable code. 
BUT there are also arguments to not use <code>make_shared&lt;T&gt;</code>, e.g., it does not permit the specification of a custom deleter.</p>
<p>More information on:</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>shared_ptr&lt;T&gt;</code> on cppreference.com</a></li>
</ul>
<h3><code>weak_ptr&lt;T&gt;</code></h3>
<p>The <code>weak_ptr&lt;T&gt;</code> smart pointer is something different from <code>shared_ptr&lt;T&gt;</code>: it holds a <strong>weak reference</strong> to the hold object.
To put it informally: <em>it allows you to look if an object is still around, but it does not keep the object around if nobody else needs it.</em> 
A <code>weak_ptr&lt;T&gt;</code> can point to an object by copy or assignment from a <code>shared_ptr&lt;T&gt;</code> or an existing <code>weak_ptr&lt;T&gt;</code>.</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Foo&gt; sp(new Foo);
std::weak_ptr&lt;Foo&gt; wp(sp);                      // constructs a weak_ptr from a shared_ptr
std::weak_ptr&lt;Foo&gt; wp2(wp);                     // construct weak_ptr out of copy constructor
std::weak_ptr&lt;Foo&gt; wp3;                         // empty weak_ptr
wp3 = wp;                                       // assignement of weak_ptr
</code></pre>
<p>While <code>shared_ptr&lt;T&gt;</code> has an influence on the lifetime of the managed object, a <code>weak_ptr&lt;T&gt;</code> only <strong>observes</strong> the object, meaning that when you destroy or reassign a <code>weak_ptr&lt;T&gt;</code>, it will <strong>not influence the reference count</strong> in the manager object.
Actually, the manager object also has an additional counter, the <strong>weak count</strong>, that keeps track of how many <code>weak_ptr&lt;T&gt;</code> objects are pointing to it, plus 1 if the normal reference count &gt; 0 (to understand why 1 is added, read <a href="https://stackoverflow.com/a/5671308">here</a> and <a href="https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p/">here</a>).</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Foo&gt; sp(new Foo);
std::shared_ptr&lt;Foo&gt; sp2(sp);                     // reference count increases
std::cout &lt;&lt; sp.use_count() &lt;&lt; std::endl;         // 2
std::weak_ptr&lt;Foo&gt; wp(sp);                        // reference count does NOT increase
std::cout &lt;&lt; sp.use_count() &lt;&lt; std::endl;         // 2
</code></pre>
<p>It is actually not even possible to get the referenced object <em>directly</em> from a <code>weak_ptr&lt;T&gt;</code>, you can only check if the referenced object was already deleted or not, by using the <code>expired()</code> member function:</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Foo&gt; sp(new Foo);
std::weak_ptr&lt;Foo&gt; wp(sp);

// wp.reset();                                          // REMARK: unlike shared_ptr&lt;T&gt;,
                                                        // you can not do wp = nullptr;

if (wp.expired())                                       // test if the weak pointer
  std::cout &lt;&lt; "Pointing to nothing..." &lt;&lt; std::endl;   // is pointing to nothing
else
  std::cout &lt;&lt; "Alive and kicking!" &lt;&lt; std::endl;
</code></pre>
<p>If you want to get access to the referenced object, you can create a <code>shared_ptr&lt;T&gt;</code> from the <code>weak_ptr&lt;T&gt;</code>, using the <code>lock()</code> member function or the <code>shared_ptr&lt;T&gt;</code> constructor:</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Foo&gt; sp(new Foo);
sp = nullptr;
std::weak_ptr&lt;Foo&gt; wp(sp);
std::shared_ptr&lt;Foo&gt; sp2 = wp.lock();              // Option 1
std::shared_ptr&lt;Foo&gt; sp3(wp);                      // Option 2
</code></pre>
<p>Find out yourself what the difference is between using the lock function or the <code>shared_ptr&lt;T&gt;</code> constructor when the <code>weak_ptr&lt;T&gt;</code> already expired before extracting the <code>shared_ptr&lt;T&gt;</code> out of it!</p>
<div class="alert alert-success">
<p>In addition to tracking a referenced object and even allow ownership over it (by converting it to a <code>shared_ptr&lt;T&gt;</code>), <code>weak_ptr&lt;T&gt;</code> can also be used to break <code>shared_ptr&lt;T&gt;</code> cyclic references: <a href="https://stackoverflow.com/questions/27085782/how-to-break-shared-ptr-cyclic-reference-using-weak-ptr">here</a> you'll find a nice example.</p>
</div>
<p>More information on:</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/memory/weak_ptr"><code>weak_ptr&lt;T&gt;</code> on cppreference.com</a></li>
</ul>
<h3><code>unique_ptr&lt;T&gt;</code></h3>
<p>A <code>unique_ptr&lt;T&gt;</code> implements, in contrast to <code>shared_ptr&lt;T&gt;</code>, <strong>exclusive ownership</strong>.
So, while you can also point to an allocated object with <code>unique_ptr&lt;T&gt;</code>, the pointed-to object gets automatically destroyed when the <code>unique_ptr&lt;T&gt;</code> goes out-of-scope.
The semantics of <code>unique_ptr&lt;T&gt;</code> are different from the <em>shared ownership</em> semantics of <code>shared_ptr&lt;T&gt;</code>.
More specifically, a unique pointer to an object may not be copied because <em>"No two unique_ptr instances can manage the same object"</em>. 
The copy constructor and copy assignment are actually not allowed (i.e., <code>=delete</code>).
In other words: there's just one unique pointer to an object at the same time.
An object's ownership can be transferred to another unique pointer though!</p>
<p>An advantage of this exclusive ownership is that the cost of a <code>unique_ptr&lt;T&gt;</code> compared to that raw pointer is nothing (except when you provide a custom deleter)!
In contrast to the overhead of <code>shared_ptr&lt;T&gt;</code> with its manager object and incrementing/decrementing/testing the counters, a <code>unique_ptr&lt;T&gt;</code> is much more cost-friendly.</p>
<pre class="prettyprint"><code>std::unique_ptr&lt;Foo&gt; up(new Foo);                    // uniquely-owned object
std::unique_ptr&lt;Foo&gt; up2(new Foo);                   // uniquely-owned object
// std::unique_ptr&lt;Foo&gt; up3(up);                     // ERROR - copy constructor not allowed!
// up2 = up;                                         // ERROR - copy assignment not allowed!
</code></pre>
<p>To transfer ownership over a <code>unique_ptr&lt;T&gt;</code>, we can use move construction and/or move assignment:</p>
<pre class="prettyprint"><code>std::unique_ptr&lt;Foo&gt; up(new Foo);               // up owns a Foo object
std::unique_ptr&lt;Foo&gt; up2;                       // up2 owns nothing!

std::unique_ptr&lt;Foo&gt; up3(std::move(up));        // move construction
                                                // up3 now owns the Foo object, up owns nothing anymore
up2 = std::move(up3);                           // move assignment:
                                                // up3 owns nothing anymore, up2 owns the Foo object
</code></pre>
<p>We'll go deeper into move semantics, rvalue references, <code>std::move()</code> (which casts its element to a rvalue reference) in Session 6.
Good to know already is that you can pass the ownership of a <code>unique_ptr&lt;T&gt;</code> out of a function:</p>
<pre class="prettyprint"><code>unique_ptr&lt;Foo&gt; createFoo() {
  std::unique_ptr&lt;Foo&gt; tmpFoo(new Foo);              // create a Foo object
  return tmpFoo;
}

std::unique_ptr&lt;Foo&gt; foo = createFoo();              // foo now owns the object
</code></pre>
<p>If you need shared ownership over a uniquely owned object, you can also easily convert a <code>unique_ptr&lt;T&gt;</code> object a <code>shared_ptr&lt;T&gt;</code> object:</p>
<pre class="prettyprint"><code>std::shared_ptr&lt;Foo&gt; sharedFoo = createFoo();
</code></pre>
<p>As in the case of <code>shared_ptr&lt;T&gt;</code>, there's a utility function to allocate an object and call its constructor: <code>make_unique&lt;T&gt;</code>.
In contrast to <code>make_shared&lt;T&gt;</code> which was introduced in <span class="label label-danger">C++11</span>, <code>make_unique&lt;T&gt;</code> was only introduced in <span class="label label-success">C++14</span>.</p>
<pre class="prettyprint"><code>auto up = std::make_unique&lt;Foo&gt;();
</code></pre>
<p>The <code>unique_ptr</code> is actually the <span class="label label-danger">C++11</span>'s replacement of the C++98 <code>std::auto_ptr</code> smart pointer. 
While <code>std::auto_ptr</code> worked, the lack of move semantics (introduced in C++11) made it so much harder to work with.
Note that <code>std::auto_ptr</code> is <strong>deprecated</strong> now!</p>
<p>More information on:</p>
<ul>
<li><a href="http://en.cppreference.com/w/cpp/memory/unique_ptr"><code>unique_ptr&lt;T&gt;</code> on cppreference.com</a></li>
<li><a href="http://msdn.microsoft.com/en-us/library/vstudio/hh279676.aspx"><code>unique_ptr</code> on MSDN</a></li>
</ul>
<h2 id="exercises">Exercises</h2>
<h3>Divide by zero</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/8sJwOrNS">https://classroom.github.com/a/8sJwOrNS</a></p>
<h3>Abstract Pizza Factory</h3>
<p>Go to the assignment: <a href="https://classroom.github.com/a/LjbmBpV-">https://classroom.github.com/a/LjbmBpV-</a></p></div></body></html>
					</div>
				</div>
			</div>

			<div class="footer">
				<p class="text-muted">&copy; <a href="mailto:thomas.ave@uantwerpen.be">Thomas Av√©</a> / IDLab / Universiteit Antwerpen.</p>
			</div>
		</div>

		<script src="https://code.jquery.com/jquery.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/google-code-prettify/prettify.js"></script>
	</body>
</html>
